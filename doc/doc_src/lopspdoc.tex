\chapter{Loop Spaces}

\section{Introduction}

Let us recall the definition of the  {\em free group} generated by a set ${\cal A}$.
Consider the set ${\cal A}\times \lbrace +1, -1 \rbrace$ and
make, as long as there is no ambiguity, the identification $a_i= (a_i,1)$ and $a_i^{-1}= (a_i,-1)$
for all $a_i\in{\cal A}$.

\paragraph{Definition}.  $a_i$ and its formal inverse $a_i^{-1}$ are  {\em letters}.

\paragraph{Definition}. A word is a {\em finite} sequence of letters, possibly repeated,
without any pair of the form $a_ja_j^{-1}$ and $a_k^{-1}a_k$. The word is said {\em reduced}.

Now, let $\Z^{*{\cal A}}$ the set of {\em  words} on $\cal A$.
It is easy to show that if we define in $\Z^{*{\cal A}}$ an internal law of composition as the
formal {\em concatenation} of two words,
on which the cancelation rule is applied, i.e. any pair of the form
$a_ja_j^{-1}$ and $a_k^{-1}a_k$ is replaced by the {\em void sequence},
then $\Z^{*{\cal A}}$ is a group (non-commutative in general).
The void word is the neutral element for that law. If we consider
the concatenation as a  {\em product}, then, as usual in group theory,
a sequence of $k$ times the same letter $a$
will be written $a^k$ and a sequence of $k$ times the same letter $a^{-1}$,
$a^{-k}$. So a word
formed from letters by the  concatenation product together with the cancellation rule,
will be written under the reduced form:
$$a_1^{n_1}a_2^{n_2}\ldots a_k^{n_k},\ n_i\in \mathbb{Z}^*,\ a_i\in {\cal A},\  a_i \not= a_{i+1}$$
and its inverse is
$$a_k^{-n_k}\ldots a_2^{-n_2}a_1^{-n_1}.$$
After this r\'esum\'e, let $X$ be a reduced simplicial set (i.e. having only one $0$--simplex,
namely its base point). The Kan simplicial version\index{loop space! Kan simplicial version} $GX$
of the loop space $\Omega(|X|)$ is defined as follows.
The set of $n$--simplices $GX_n$ is the free group generated by the $(n+1)$--simplices
$\sigma \in X_{n+1}$ except those which are $n$--degenerate. In other words:
$$ GX_n=\Z^{*X^+_{n+1}},\ X^+_{n+1}=X_{n+1}-\eta_n X_n. $$
In fact, from a strictly mathematical point of view, the right definition is
$$ GX_n = \Z^{*X^+_{n+1}} / {\overline{\eta_n X_n}},$$
i.e. the quotient group of $\Z^{*X^+_{n+1}}$, the free group generated by {\bf all} the $n+1$--simplices,
the $n$--degenerate included, by  the normal subgroup ${\overline{\eta_n X_n}}$ generated by
the $n$--degenerate simplices. Both definitions are equivalent, the second is mathematicaly
correct but only the first one is visible in the program.
\vskip 0.35cm
For a better understanding, we may distinguish carefully a generator $\sigma$ belonging to  $X_{n+1}$ and
the corresponding letter  $\tau (\sigma) \in GX_n$. So a word, element
of $GX_n$ will be written
$${\tau(\sigma_1)}^{\epsilon_1} {\tau(\sigma_2)}^{\epsilon_2} \ldots {\tau(\sigma_p)}^{\epsilon_p}.$$
Now, let us define two homomorphisms:
$$ \overline{\partial}_i^n: GX_n \longrightarrow GX_{n-1},\ \overline{\eta}_i^n: GX_n \longrightarrow GX_{n+1},$$
by the following relations, keeping in mind that $\partial_i$ and $\eta_i$ are respectively the face
and degeneracy operators acting on the  simplices of  $X$:
\begin{eqnarray*}
\overline{\partial}_i(\tau(\sigma))  & = & \tau(\partial_i\sigma),\qquad 0 \leq i < n, \\
\overline{\partial}_n(\tau(\sigma))  & = & \tau(\partial_{n+1}\sigma)^{-1}\tau(\partial_n\sigma), \\
\overline{\eta}_i(\tau(\sigma))    & = & \tau(\eta_i\sigma),\qquad 0 \leq i \leq n.
\end{eqnarray*}
When applied to words, the two homomorphisms, $\overline{\partial}$ and $\overline{\eta}$,  satisfy
(for cla\-ri\-ty, we omit here the operator $\tau$):
\begin{eqnarray*}
\overline{\partial}(a_1^{n_1}\ldots a_k^{n_k}) &=& (\overline{\partial}(a_1))^{n_1}\ldots
                                                   (\overline{\partial}(a_k))^{n_k}, \\
\overline{\eta}(a_1^{n_1}\ldots a_k^{n_k}) &=& (\overline{\eta}(a_1))^{n_1}\ldots (\overline{\eta}(a_k))^{n_k}.
\end{eqnarray*}
It is known  that the $\overline{\partial}_i$ and the $\overline{\eta}_i$ satisfy the
fundamental relations between face and degeneracy operators (see the chapter on simplicial sets). So,
$GX$ is itself a simplicial set; each $GX_n$ is a group, each face and degeneracy operator
is an homomorphism, so that $GX$ is a {\em simplicial group}.
The importance of the simplicial group $GX$ is emphasized by the Kan theorem, stating
that if we consider the realization $|X|$ of $X$ and the loop space  $\Omega(|X|, x_0)$ at
the base point $x_0 \in |X|$,  then $\Omega(|X|, x_0)$ and
the realization $|GX|$ of $GX$ have the same  homotopy type.

\section {Representation of letters and words}

In the system, the chosen representation for letters and words follows the very definition
of the free group $\mathbb{Z}^{*X_{n+1}^+}$. Here, a letter is a generator of $GX_n$ i.e. an {\bf abstract simplex}
$\sigma$ of $X^+_{n+1}$.
A word will be implemented  as a sequence of such letters to a certain power (including 1).
The chosen terminology is the following:
\begin{itemize}
\item A term like $\sigma^p$ is a {\bf power}.
\item A word ${\sigma_1}^{\epsilon_1} {\sigma_2}^{\epsilon_2} \ldots {\sigma_p}^{\epsilon_p}$
is a {\bf loop}.
\end{itemize}
Note that, in this framework the operator $\tau$ is not visible.

\subsection{Representation of a power}

A power is internally represented by  lisp object of type  {\tt apowr}. This has the form:
\begin{center}
{\tt ({\em dgop} {\em gmsm} . {\em expn})}
\end{center}
in which we may recognize:
\begin{enumerate}
\item the components of the abstract simplex: {\em dgop} and {\em gmsm},
\item the exponent of the letter: {\em expn}, an integer.
\end{enumerate}
The associated  constructor is the macro {\tt apowr}.
\vskip 0.45cm
{\parindent=0mm
{\leftskip=5mm
{\tt apowr} {\em dgop gmsm expn} \hfill {\em [Macro]} \par}
{\leftskip=15mm
Build an object of type  {\tt apowr}.
The accessor macros  are respectively {\tt apdgop},  {\tt apgmsm} and {\tt apexpn}. There
is no special printing function since the real object interesting for the user is not
the power but rather the loop.\par}
}

\subsection{Representation of a loop}

A\index{loop space!representation of a loop} loop is represented by a lisp object of the form:
\begin{center} {\tt (:loop $apower_1$ ... $apower_k$)} \end{center}
The corresponding type is {\tt LOOP}.
The  constructor is the macro {\tt make-loop} but the pratical one is {\tt loop3} and the associated
printing function prints the object under the form:
\begin{center}
{\tt <<Loop [{\em ext-dgop1 gmsm1} {\em expn1}] ... [{\em ext-dgopk gmsmk} {\em expnk}]>>}
\end{center}
where the {\em ext-dgop}'s are under the form of a readable sequence of $\eta$ operators.

\subsubsection {Notion of normalized loop}

Normalizing\index{loop space!normalized loop} a loop is a matter of factoring the degeneracy operators
components (the {\em dgop}'s) of the
{\em apowr}'s and building an  object of type {\tt ABSM}  belonging to the simplicial set $GX$.
For instance, the normalized null-loop in dimension $5$ is {\tt <AbSm 4-3-2-1-0 <<Loop>>>}. For non-null
loops, the following examples show the transformation. We have written the loops under the form printed by the
system.
{\footnotesize\begin{verbatim}
<<Loop [1-0 A\2]>> ===>  <AbSm 1-0 <<Loop [A\2]>>>

<<Loop [3-2-1 A\2] [4-2 B\3]>>  ===>  <AbSm 2 <<Loop [2-1 A\2] [3 B\3]>>>.

<<Loop [2-1 A\2] [2-0 B\2] [1-0 A\3]>> ===>

       <AbSm - <<Loop [2-1 A\2] [2-0 B\2] [1-0 A\3]>>>

<<Loop [2-1-0 A\2] [2-1-0 B\2] [2-1-0 A\3]>> ===>

       <AbSm 2-1-0 <<Loop [A\2] [B\2] [A\3]>>>
\end{verbatim}}

\section{A set of functions for loops}

To facilitate the construction of objects of {\tt LOOP} type,
a set of useful functions is provided by the system.
\vskip 0.50cm
{\parindent=0mm
{\leftskip=5mm
{\tt loop3} {\em dgop1 gmsm1 pwr1 ... dgopk gmsmk pwrk} \hfill {\em [Function]} \par}
{\leftskip=15mm
Construct a  loop (a word) corresponding to the product of the abstract simplices $asm_i$, the components
of which being $dgop_i$ and $gmsm_i$,  to
the power $pwr_i$. The function constructs  itself the  objects of type {\tt apowr}  from the arguments.
It  accepts an indefinite number of arguments, including none.
If there is no argument, the null loop is created. It exists in fact in the system
the constant {\tt +null-loop+} which is  the base point of the underlying simplicial group.
{\bf Warning}: the function {\tt loop3} does
return neither a normalized loop nor a reduced word (no automatic simplification),
so it is up to the user to give a correct sequence of arguments
cor\-res\-pon\-ding to  a reduced word.
\par}
{\leftskip=5mm
{\tt loop-space-cmpr} {\em cmpr} \hfill {\em [Function]}  \par}
{\leftskip=15mm
From the comparison function {\em cmpr} suitable for comparing the geometrical simplices belonging to the
underlying simplicial set, build a comparison function for objects of type {\tt LOOP}. \par}
{\leftskip=5mm
{\tt loop-space-face} {\em cmpr face} \hfill {\em [Function]}  \par}
{\leftskip=15mm
From the comparison function {\em cmpr} and the face function {\em face}, build a face function
for an object of type {\tt LOOP} returning the face of such an object  as an {\tt ABSM} type object
(a normalized loop). \par}
{\leftskip=5mm
{\tt loop-space-face*} {\em cmpr face} \hfill {\em [Function]}  \par}
{\leftskip=15mm
From the comparison function {\em cmpr} and the face function {\em face}, build a face* function.
See the description of the slot {\tt face*} in the simplicial sets chapter. \par}
{\leftskip=5mm
{\tt loop-space-grml-sintr} {\em cmpr} \hfill {\em [Function]}  \par}
{\leftskip=15mm
From the comparison function {\em cmpr}, build a function for the group operation of the loop space
(a simplicial group). \par}
{\leftskip=5mm
{\tt loop-space-grin-sintr} {\em dmns loop} \hfill {\em [Function]}  \par}
{\leftskip=15mm
Build the inverse of the object {\em loop} in the simplicial group. The first argument {\em dmns}
is mandatory but ignored. \par}
{\leftskip=5mm
{\tt loop-space} {\em smst} {\tt \&optional (n 1)} \hfill {\em [Function]}  \par}
{\leftskip=15mm
If the second argument is {\tt 1} or omitted, construct, from the {\bf reduced} simplicial set $X$,
here the argument {\em smst}, the  corresponding simplicial
group $GX$. The new created simplicial set is of course locally effective and its base point is the null loop.
For any other positive integer value $n$ of the second argument, build the $n$-th i\-te\-ra\-ted loop space of $X$.
The basic construction is given by the following call to the function {\tt build-smgr}:
{\footnotesize\begin{verbatim}
                  (build-smgr   :cmpr (loop-space-cmpr cmpr)
                                :basis :locally-effective
                                :bspn +null-loop+
                                :face (loop-space-face cmpr face)
                                :face* (loop-space-face* cmpr face)
                                :sintr-grml (loop-space-grml-sintr cmpr)
                                :sintr-grin #'loop-space-grin-sintr
                                :orgn `(loop-space ,smst))
\end{verbatim}}
 \par}
{\leftskip=5mm
{\tt gdeltab} \hfill {\em [Function]} \par}
{\leftskip=15mm
Build $\Omega^1(\bar{\Delta})$. This is simply {\tt (loop-space(deltab))}.
We recall that $\bar{\Delta}$ is the reduced and locally effective simplicial set
obtained from ${\Delta}^{\N}$,  by identifying all the vertices to the base point.
$\Delta^{\N}$ is the locally effective simplicial set freely generated
by the positive integers. \par}
}

\subsection*{Examples}

{\footnotesize\begin{verbatim}
(loop3)  ==>

<<Loop>>

(loop3 0 'a 2 20 'b -3 12 'c 1)  ==>

<<Loop [A\2] [4-2 B\-3] [3-2 C]>>

(loop3 0 'a 2 20 'b -3 12 'c 1 0 'a 3)  ==>

<<Loop [A\2] [4-2 B\-3] [3-2 C] [A\3]>>

(loop3 (dgop-ext-int '(2 1 0)) 'p 2
       (dgop-ext-int '(5 4 3 2 1)) 'q 5)  ==>

<<Loop [2-1-0 P\2] [5-4-3-2-1 Q\5]>>
\end{verbatim}}

Let us consider now a true reduced simplicial set, namely $Moore(\mathbb{Z}/{2\mathbb{Z}}, 3)$,
whose structure is shown using the function {\tt show-structure} defined in the Simplicial Sets chapter.
{\footnotesize\begin{verbatim}
(setf moore23 (moore 2 3)) ==>

[K7 Simplicial-Set]

(show-structure moore23 4)  ==>


Dimension = 0 :

        Vertices :  (*)

Dimension = 1 :

Dimension = 2 :

Dimension = 3 :

        Simplex : M3

                Faces : (<AbSm 1-0 *> <AbSm 1-0 *>
                         <AbSm 1-0 *> <AbSm 1-0 *>)

Dimension = 4 :

        Simplex : N4

                Faces : (<AbSm - M3> <AbSm 2-1-0 *>
                         <AbSm - M3> <AbSm 2-1-0 *> <AbSm 2-1-0 *>)
\end{verbatim}}
Let us build now $\Omega^1(Moore(\mathbb{Z}/{2\mathbb{Z}}, 3))$ and ask for faces of some loops.
The user will note that the function face admits either {\tt LOOP} type objects or
{\tt ABSM} type objects (normalized loop) but always returns normalized loops, i.e.
an abstract simplex, according to the normal behaviour of the face function in a
simplicial set.
{\footnotesize\begin{verbatim}
(setf o-moore23 (loop-space moore23))  ==>

[K11 Simplicial-Group]

(face o-moore23 0 4 +null-loop+)  ==>

<AbSm 2-1-0 <<Loop>>>

(face o-moore23 0 3 (loop3 0 'N4 2))  ==>

<AbSm - <<Loop [M3\2]>>>

(face o-moore23 1 3 (loop3 0 'N4 2))  ==>

<AbSm 1-0 <<Loop>>>

(face o-moore23 1 4 (loop3 1 'N4 2))  ==>

<AbSm - <<Loop [N4\2]>>>

(face o-moore23 0 2 (loop3 0 'M3 2))  ==>

<AbSm 0 <<Loop>>>
\end{verbatim}}
\newpage
Let us do the same with the following reduced simplicial set ({\tt ss2}) and with $\Omega^1(\bar{\Delta})$.
{\footnotesize\begin{verbatim}
(setf ss2 (build-finite-ss '( *
                              2 s2 (* * *)
                              3 s3 (s2 s2 s2 s2))))  ==>

Checking the 0-simplices...
Checking the 1-simplices...
Checking the 2-simplices...
Checking the 3-simplices...
[K18 Simplicial-Set]

(setf o-ss2 (loop-space ss2))  ==>

[K23 Simplicial-Group]

(face o-ss2 0 1 (loop3 0 's2 1))  ==>

<AbSm - <<Loop>>>

(face o-ss2 0 2 (loop3 0 's3 2))  ==>

<AbSm - <<Loop [S2\2]>>>

(face o-ss2 1 2 (loop3 0 's3 2))  ==>

<AbSm - <<Loop [S2\2]>>>

(face o-ss2 1 2 (loop3 0 's3 2))  ==>

<AbSm - <<Loop [S2\2]>>>

(setf db (gdeltab))  ==>

[K40 Simplicial-Group]

(face db 3 3 (loop3 12 7 3))  ==>

<AbSm 1-0 <<Loop>>>

(face db 3 3 (loop3 5 7 3))  ==>

<AbSm 0 <<Loop [7\3]>>>

(face db 3 3 (loop3 6 7 3 5 7 3 3 7 3))  ==>

<AbSm - <<Loop [1 7\3] [0 7\3] [1-0 3\-1] [1-0 5] [1-0 3\-1]
               [1-0 5] [1-0 3\-1] [1-0 5]>>>

(face db 3 2 *)  ==>

<AbSm - <<Loop [7\3] [0 3\-1] [0 5] [0 3\-1] [0 5] [0 3\-1]
               [0 5] [0 3\-1] [0 5] [0 3\-1] [0 5] [0 3\-1] [0 5]>>>
\end{verbatim}}
The last  statement shows that the boundary operator attached to
the chain complex derived from all this machinery satisfies its fundamental
property ($d\circ d=0$).
{\footnotesize\begin{verbatim}
(? db (? db 3 (loop3 (dgop-ext-int '(3 2)) (dlop-ext-int '(0 1 2)) 3
                     (dgop-ext-int '(3 1)) (dlop-ext-int '(0 1 2)) 3
                     (dgop-ext-int '(2 1)) (dlop-ext-int '(0 1 2)) 3)))  ==>

----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------
\end{verbatim}}
The loop spaces of reduced simplicial sets, provide us with new examples of algebras. So, we may apply
the functor {\tt bar}.
{\footnotesize\begin{verbatim}
(setf moore-22 (moore 2 2))  ==>

[K1 Simplicial-Set]

(dotimes (i 4) (print (basis moore-22  i :dgnr)))  ==>

(<AbSm - *>)
(<AbSm 0 *>)
(<AbSm - M2> <AbSm 1-0 *>)
(<AbSm - N3> <AbSm 0 M2> <AbSm 1 M2> <AbSm 2 M2> <AbSm 2-1-0 *>)

(setf o-moore-22 (loop-space moore-22))  ==>

[K6 Simplicial-Group]

(aprd o-moore-22 3 (tnpr 1 (loop3 0 'm2 1) 2 (loop3 0 'n3 1)))  ==>

----------------------------------------------------------------------{CMBN 3}
<1 * <<Loop[1-0 M2][2 N3]>>>
<-1 * <<Loop[2-0 M2][1 N3]>>>
<1 * <<Loop[2-1 M2][0 N3]>>>
------------------------------------------------------------------------------

(setf bar-om (bar o-moore-22))  ==>

[K36 Chain-Complex]
\end{verbatim}}
\newpage
{\footnotesize\begin{verbatim}
(? bar-om 5 (abar 2 (loop3 0 'm2 1) 3 (loop3 0 'n3 1)))  ==>

----------------------------------------------------------------------{CMBN 4}
<1 * <<Abar[4 <<Loop[1-0 M2][2 N3]>>]>>>
<-1 * <<Abar[4 <<Loop[2-0 M2][1 N3]>>]>>>
<1 * <<Abar[4 <<Loop[2-1 M2][0 N3]>>]>>>
<-2 * <<Abar[2 <<Loop[M2]>>][2 <<Loop[M2]>>]>>>
------------------------------------------------------------------------------
\end{verbatim}}

\subsection* {Lisp file concerned in this chapter}

{\tt loop-spaces.lisp}.
