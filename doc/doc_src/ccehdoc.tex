\chapter {Objects with effective homology}

\section {Introduction}

The present chapter describes the set of programming tools for handling
{\em objects with effective homology}. The theoretical material may be
found in the paper {\em Constructive Algebraic Topology} by
Julio Rubio Garcia and Francis Sergeraert\footnote{Available at the web site
{\bf http://www-fourier.ujf.grenoble.fr/\~\,sergerar/}}.
The terminology used in this
chapter is compatible with this reference.

\section {Reduction}

A {\em reduction}\index{reduction!in {\tt Kenzo}} is a 5--tuple $(\hat C, C, f, g, h)$:
$$
\begin{array}{l}
\hspace{10pt} \hat{C} \stackrel{h}{\longrightarrow}\mbox{$^s\hat{C}$} \\
{\scriptstyle f} \downarrow \uparrow {\scriptstyle g}\\
\hspace{10pt} C
\end{array}
$$
where $\hat C$ and $C$ are chain complexes, $f$ and $g$  chain complex morphisms and
$h$ a homotopy operator. Hereafter, $\hat C$ is called the {\em top chain complex}\index{chain complex!top (reduction)}
and $C$ the {\em bottom chain complex}\index{chain complex!bottom (reduction)}.
${}^s\hat C$ is $\hat C$ shifted, i.e. $h$ has
degree $1$. The mappings $f$, $g$, $h$, together with the differential operator $d$
on $\hat C$, must verify the following relations:
\newpage
\begin{eqnarray*}
f \circ g & = & 1_C \\
h \circ d + d \circ h & = & 1_{\hat C} - g \circ f \\
f \circ h & = & 0   \\
h \circ g & = & 0   \\
h \circ h & = & 0
\end{eqnarray*}
The morphisms $f$ and $g$ and the homotopy operator $h$ describe the (big) chain
complex $\hat C$ as the direct sum
$$ \hat C= \hat C_1 \oplus \hat C_2$$
where $\hat C_1 = Im(g) \simeq C$ and  $\hat C_2= Ker(f)$ ($\hat C_2$ is acyclic).

\subsection {Representation of a reduction}

A reduction\index{reduction!representation} is implemented as an instance of
the {\tt CLOS} class {\tt REDUCTION}\index{class! {\tt REDUCTION}}, whose
definition is:
{\footnotesize\begin{verbatim}
(DEFCLASS REDUCTION ()
     ;; Top Chain Complex
    ((tcc :type chain-complex :initarg :tcc :reader tcc1)
     ;; Bottom Chain Complex
     (bcc :type chain-complex :initarg :bcc :reader bcc1)
     (f :type morphism :initarg :f :reader f1)
     (g :type morphism :initarg :g :reader g1)
     (h :type morphism :initarg :h :reader h1)
     ;; IDentification NuMber
     (idnm :type fixnum :initform (incf *idnm-counter*) :reader idnm)
     ;; ORiGiN
     (orgn :type list :initarg :orgn :reader orgn)))
\end{verbatim}}
This class has $7$  slots:
\begin{enumerate}
\item {\tt tcc}, the object of type {\tt chain-complex} representing the chain complex $\hat C$
(\b top \b chain \b complex).
\item {\tt bcc},  the object of type {\tt chain-complex}  representing the chain complex $C$
(\b bottom \b chain \b complex).
\item {\tt f}, the object of type {\tt morphism}  representing the morphism $f$.
\item {\tt g}, the object of type {\tt morphism}  representing the morphism $g$.
\item {\tt h}, the object of type {\tt morphism}  representing the morphism $h$.
\item {\tt idmn}, an integer, number plate for the object.
\item {\tt orgn}, a comment list carefully chosen.
\end{enumerate}
The accessors of the slots are the functions whose name appears after the specifier {\tt:reader} in
the class definition. A printing method has been associated to the class {\tt REDUCTION}
and the external representation of an instance is a string like {\tt [K{\em n} Reduction]}, where $n$
is the number plate of the Kenzo object.

\subsection {The function build-rdct}

To facilitate the construction of instances of the  {\tt REDUCTION} class, the
software provides the function {\tt build-rdct}\index{function!{\tt build-rdct}}.
\vskip 0.45cm
{\tt build-rdct :f} {\em f} {\tt :g} {\em g} {\tt :h} {\em h} {\tt :orgn} {\em orgn}
\vskip 0.40cm
defined with keyword parameters. The returned value is an instance of the class {\tt REDUCTION}.
The keyword arguments are:
\begin{itemize}
\item[--] {\em f}, the object of type {\tt morphism}  representing the morphism $f$.
\item[--] {\em g}, the object of type {\tt morphism}  representing the morphism $g$.
\item[--] {\em h}, the object of type {\tt morphism}  representing the morphism $h$.
\item[--] {\em orgn}, the comment list carefully chosen since the system does not
build a new instance of the class if it finds in the list of already built reductions, {\tt *rdct-list*},
a reduction  with the same comment list.
\end{itemize}
The {\tt tcc} slot and the {\tt bcc} slot of the instance are taken respectively
from the {\tt sorc} slot (source slot) and  the {\tt trgt} slot (target slot) of the morphism $f$.
The function {\tt build-rdc} controls the validity of the degrees of the morphisms and
pushes the new created  instance on the list {\tt *rdct-list*}.

\newpage

\subsection {Useful macros and functions}

{\parindent=0mm
{\leftskip=5mm
{\leftskip=5mm
{\tt cat-init} \hfill {\em [Function]} \par}
{\leftskip=15mm
Clear among others, the list {\tt *rdct-list*}, list of user created reductions  and reset
the global counter to $1$. See also the description of this function in chapter 1. \par}
{\tt rdct} {\em n}\hfill {\em [Function]} \par}
{\leftskip=15mm
Retrieve in the list {\tt *rdct-list*} the reduction instance whose identification
(as {\tt Kenzo} object) is $n$. If it does not exist, return {\tt NIL}. \par}
{\leftskip=5mm
{\tt bcc} {\em rdct {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a reduction {\em rdct}) this macro selects
the bottom chain complex of the reduction. Otherwise, it applies  the differential
of the bottom chain complex of the reduction {\em rdc} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt tcc} {\em rdct {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a reduction {\em rdct}) this macro selects
the top chain complex of the reduction. Otherwise, it applies  the differential
of the top chain complex of the reduction {\em rdc} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt f} {\em rdct {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a reduction {\em rdct}) this macro selects
the morphism $f$ of the reduction. Otherwise, it applies  the morphism $f$
of the reduction {\em rdc} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt g} {\em rdct {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a reduction {\em rdct}) this macro selects
the morphism $g$ of the reduction. Otherwise, it applies  the morphism $g$
of the reduction {\em rdc} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt h} {\em rdct {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a reduction {\em rdct}) this macro selects
the morphism $h$ of the reduction. Otherwise, it applies  the morphism $h$
of the reduction {\em rdc} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
}
\newpage
{\parindent=0mm
{\leftskip=5mm
{\tt trivial-rdct} {\em chcm}\hfill {\em [Function]} \par}
{\leftskip=15mm
Build the trivial reduction involving only the chain complex {\em chcm}, as shown in the following diagram,
$$
\diagram{
 C & \stackrel{Zero} {\longrightarrow} & {}^s C \cr
 {\scriptstyle {Id}} \downarrow \uparrow {\scriptstyle {Id}}  \cr
  C \cr
}
$$
where  the morphism {\em Zero} is the zero morphism of degree $1$ in the chain complex $C$
and {\em Id} is the identity morphism in that chain complex (see the functions
{\tt zero-mrph} and {\tt idnt-mrph} in the chain complex chapter). \par}
{\leftskip=5mm
{\tt cmps} {\em brdct trdct}\hfill {\em [Method]} \par}
{\leftskip=15mm
Build a new reduction from the two reductions $r1$ and $r2$ (here, respectively {\em brdct} and {\em trdct}).
This is done by a call to {\tt build-rdct} with the following parameters:
\begin{eqnarray*}
f & = & f_{r1}\circ f_{r2}, \\
g & = & g_{r2}\circ g_{r1}, \\
h & = &  h_{r2}  + g_{r2} \circ h_{r1} \circ f_{r2}.
\end{eqnarray*}
The compositions and additions of morphisms are realized respectively by the methods
{\tt cmps}, {\tt i-cmps}  and   {\tt add } (see chapter~1).
We recall that the {\tt tcc}  and the {\tt bcc} slots of this new created
reduction  are respectively
the source and target slots of the new morphim $f$.
\par}
}
\subsection {Verification functions}

The two following functions\index{reduction!verification} are very helpful to verify the coherence of the
the various mappings involved in a reduction. Let us recall the diagram
of a reduction:
$$
\begin{array}{l}
\hspace{10pt} \hat{C} \stackrel{h}{\longrightarrow}\mbox{$^s\hat{C}$} \\
{\scriptstyle f} \downarrow \uparrow {\scriptstyle g}\\
\hspace{10pt} C
\end{array}
$$
\newpage
{\parindent=0mm
{\leftskip=5mm
{\tt pre-check-rdct} {\em rdct} \hfill {\em [Function]} \par}
{\leftskip=15mm
Assign to the following lisp global variables, the morphism instances computed
from the morphisms of the reduction {\em rdct}, according to the  formulas:\par}
{\leftskip 20mm
\begin{quotation}
  {\tt *tdd*}  = $ d_{\hat C} \circ d_{\hat C},$

  {\tt *bdd*}  = $ d_C \circ d_C ,$

  {\tt *id-fg*}  = $  f \circ g - Id_C,$

  {\tt *id-gf-dh-hd*}  = $ Id_{\hat C} - g \circ f - (d_{\hat C} \circ h + h \circ d_{\hat C}),$

  {\tt *hh*}  = $ h \circ h,$

  {\tt *fh*}  = $ f \circ h,$

  {\tt *hg*}  = $ h \circ g,$

  {\tt *df-fd*}  = $  d_C \circ f - f \circ d_{\hat C},$

  {\tt *dg-gd*}  = $  d_{\hat C} \circ g - g \circ d_C.$

\end{quotation} \par}
{\leftskip=15mm
In these formulas  $d_C$ and $d_{\hat C}$ are the respective boundary operators of the
chain complexes $C$ and $\hat C$. $Id_C$ and $Id_{\hat C}$ are the identity morphisms
on the chain complexes $C$ and $\hat C$  built by the function {\tt idnt-mrph} \par}
{\leftskip=5mm
{\tt check-rdct} \hfill {\em [Function]} \par}
{\leftskip=15mm
Map  all the morphisms prepared by the function {\tt pre-check-rdct} on chosen combinations.
This function having no parameters, the user must  assign
to  the two lisp global variables:
{\tt *tc*} and {\tt *bc*},  valid combinations belonging respectively to $\hat C$ and $C$.
The call to this
function is simply {\tt (check-rdct)}. This function knows what morphism to apply
to the combinations and pauses after each evaluation to allow the user to inspect each result.
To resume the execution, the user must enter a blank character.
If the morphisms are coherent, the result of each mapping is a null combination. \par}
}
\newpage

\subsection* {Example}

To show an example about the verification functions, we first define a locally effective version
of the standard simplex $\Delta^n$. The following function {\tt cdelta} builds the standard simplex
in dimension {\em dmns}. In using the created chain complex, the user must bear in mind that
the only valid vertices are the vertices numbered from $(0)$ to $(dmns)$.
{\footnotesize\begin{verbatim}
 (defun cdelta (dmns)
     (build-chcm
        :cmpr #'l-cmpr
        :basis :locally-effective
        :bsgn '(0)
        :intr-dffr
              #'(lambda (degr gmsm)
                   (make-cmbn
                     :degr (1- degr)
                     :list (do ((rslt +empty-list+
                                  (cons (cons sign
                                              (append
                                                 (subseq gmsm 0 nark)
                                                 (subseq gmsm (1+ nark))))
                                          rslt))
                                (sign 1 (- sign))
                                (nark 0 (1+ nark)))
                                ((> nark degr) rslt))))
        :strt :gnrt
        :orgn `(locally effective version of C_* delta ,dmns)))
\end{verbatim}}
Now, let us define $3$ functions {\tt make-f}, {\tt make-g} and {\tt make-h} which build the
following respective morphisms between $\Delta^m$ and $\Delta^n$:
\begin{itemize}
\item {\tt (make-f {\em tdms bdms})} builds a projection morphism $f$ from $\Delta^{tdms}$ to $\Delta^{bdms}$,
$tdms>=bdms$, where the vertices $(0)$ to $(dms)$ of $\Delta^{tdms}$ are applied on the vertices of the same
number in $\Delta^{bdms}$ and the vertices $(bdms+1)$ to $(tdms)$ are applied on the vertex $(bdms)$ of
$\Delta^{bdms}$.
\item {\tt (make-g {\em tdms bdms})} builds the injection morphism $g$ from $\Delta^{bdms}$ to $\Delta^{tdms}$
(the slot {\tt :intr} is the identity function).
\item {\tt (make-h {\em tdms bdms})} builds a homotopy morphism of degree $1$, $h$,
from $\Delta^{tdms}$ to itself, connecting w.r.t. the homotopy relation, the chain map
$g \circ f$ with the identity morphism $Id$.
\end{itemize}
\newpage
{\footnotesize\begin{verbatim}
 (defun make-f (tdmns bdmns)
   (build-mrph
     :sorc (cdelta tdmns) :trgt (cdelta bdmns) :degr 0
     :intr #'(lambda (degr gmsm)
               (let ((pos (position-if #'(lambda (vertex) (>= vertex bdmns))
                                             gmsm)))
                     (if pos
                       (if (< pos degr)
                           (zero-cmbn degr)
                           (cmbn degr 1 (nconc (butlast gmsm) (list bdmns))))
                           (cmbn degr 1 gmsm))))
     :strt :gnrt
     :orgn `(projection delta ,tdmns => delta ,bdmns)))

 (defun make-g (tdmns bdmns)
   (build-mrph
     :sorc (cdelta bdmns) :trgt (cdelta tdmns) :degr 0
     :intr #'identity
     :strt :cmbn
     :orgn `(injection delta ,bdmns => delta ,tdmns)))

 (defun make-h (tdmns bdmns)
   (build-mrph
     :sorc (cdelta tdmns) :trgt (cdelta tdmns) :degr +1
     :intr #'(lambda (degr gmsm)
              (let ((pos (position-if #'(lambda (vertex) (>= vertex bdmns))
                                             gmsm)))
                      (if pos
                          (if (member bdmns gmsm)
                              (zero-cmbn (1+ degr))
                              (cmbn (1+ degr) (-1-expt-n pos)
                               (append (subseq gmsm 0 pos) (list bdmns)
                                       (subseq gmsm pos))))
                          (zero-cmbn (1+ degr)))))
     :strt :gnrt
     :orgn `(homotopy for delta ,tdmns => ,bdmns)))
\end{verbatim}}
We may now define a function to build a reduction. One has not to define a priori the standard
simplices: this is done  in  all the functions and we know that there is no duplication, because
before creation, the system checks,
owing to the comment list, if the instance of a class (here a chain complex) already exists.
{\footnotesize\begin{verbatim}

 (defun make-rdct (tdmns bdmns)
       (setf rdct (build-rdct
                    :f (make-f tdmns bdmns)
                    :g (make-g tdmns bdmns)
                    :h (make-h tdmns bdmns)
                    :orgn `(reduction delta ,tdmns ,bdmns))))
\end{verbatim}}
We now build with a simple call to the function {\tt make-rdct} the chain complexes corresponding
to $\Delta^6$ and $\Delta^3$, the $3$ morphisms
$f$, $g$, $h$ and the reduction. The lisp utility function {\tt inspect} gives an idea
of the organisation of the class instance. Then we verify the coherency of the reduction with the functions
{\tt pre-check-rdct} and {\tt check-rdct}.
{\footnotesize\begin{verbatim}

(setf rdct (make-rdct 6 3))  ==>

[K8 Reduction]

(inspect rdct)  ==>

REDUCTION @ #x498342 = [K8 Reduction]
   0 Class --------> #<STANDARD-CLASS REDUCTION>
   1 ORGN ---------> (REDUCTION ...), a proper list with 4 elements
   2 IDNM ---------> fixnum 8 [#x00000020]
   3 H ------------> [K7 Morphism (degree 1)]
   4 G ------------> [K6 Morphism (degree 0)]
   5 F ------------> [K5 Morphism (degree 0)]
   6 BCC ----------> [K3 Chain Complex]
   7 TCC ----------> [K1 Chain Complex]

(orgn rdct)  ==>

(REDUCTION DELTA 6 3)

(pre-check-rdct rdct)  ==>

---done---

(setf *tc* (cmbn 2 1 '(0 1 2) 10 '(1 2 3) 100 '(1 2 4) 1000 '(2 3 4)))  ==>

----------------------------------------------------------------------{CMBN 2}
<1 * (0 1 2)>
<10 * (1 2 3)>
<100 * (1 2 4)>
<1000 * (2 3 4)>
------------------------------------------------------------------------------

(setf *bc* (cmbn 3 4 '(0 1 2 3)))  ==>

----------------------------------------------------------------------{CMBN 3}
<4 * (0 1 2 3)>
------------------------------------------------------------------------------

(check-rdct)  ==>

*TC* =>
----------------------------------------------------------------------{CMBN 2}
<1 * (0 1 2)>
<10 * (1 2 3)>
<100 * (1 2 4)>
<1000 * (2 3 4)>
------------------------------------------------------------------------------

*BC* =>
----------------------------------------------------------------------{CMBN 3}
<4 * (0 1 2 3)>
------------------------------------------------------------------------------

Checking *TDD* = 0
Result:
----------------------------------------------------------------------{CMBN 0}
------------------------------------------------------------------------------

Checking *BDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *DF-FD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *DG-GD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------

Checking *ID-FG* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------

Checking *ID-GF-DH-HD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------
\end{verbatim}}
\newpage
{\footnotesize\begin{verbatim}
Checking *HH* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

Checking *FH* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------

Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---
\end{verbatim}}
We do now the same thing with a more complicated reduction which is the
composition of the two following reductions:
{\footnotesize\begin{verbatim}
(setf trdct (make-rdct 6 4))  ==>

[K40 Reduction]

(setf brdct (make-rdct 4 3))  ==>

[K44 Reduction]

(setf rdct (cmps brdct trdct))  ==>

[K50 Reduction]

(pre-check-rdct rdct)  ==>

---done---

(check-rdct)  ==>

*TC* =>
----------------------------------------------------------------------{CMBN 2}
<1 * (0 1 2)>
<10 * (1 2 3)>
<100 * (1 2 4)>
<1000 * (2 3 4)>
------------------------------------------------------------------------------
\end{verbatim}}
\newpage
{\footnotesize\begin{verbatim}
*BC* =>
----------------------------------------------------------------------{CMBN 3}
<4 * (0 1 2 3)>
------------------------------------------------------------------------------

Checking *TDD* = 0
Result:
----------------------------------------------------------------------{CMBN 0}
------------------------------------------------------------------------------

Checking *BDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *DF-FD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *DG-GD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------

Checking *ID-FG* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------

Checking *ID-GF-DH-HD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------

Checking *HH* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

Checking *FH* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------
\end{verbatim}}
\newpage
{\footnotesize\begin{verbatim}
Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---
\end{verbatim}}
\newpage

\section {Homotopy equivalence}

A {\em homotopy equivalence}\index{homotopy equivalence!in {\tt Kenzo}} between two
chain complexes $C$ and $EC$ is a pair of reductions:
%$$
%\begin{array}{l}
%\hspace{30pt} \hat{C} \\
%\hspace{1pt} \raisebox{3pt}{$\rho_1$} \swarrow \hspace{12pt}
%             \searrow \raisebox{3pt}{$\rho_2$} \\
%\hspace{4pt}C \hspace{32pt} EC
%\end{array}
%$$
$$\diagram{
  & \hat{C} \cr
 \rho_1\swarrow\nearrow   & & \nwarrow\searrow \rho_2 \cr
C  & & EC \cr }
$$
If $C$ and $EC$ are {\em free} $\Z$-chain complexes, a usual chain equivalence between them can be
organized in this way. Frequently the chain complexes $C$ and $\hat C$ are {\em locally effective}
and on the contrary, the chain complex $EC$ is {\em effective}, so that $EC$ can be understood
as a description of the homology of $C$. More precisely, $EC$ is a tool allowing one to compute the
homology of $C$. The chain complexe $\hat C$ is only an intermediate object.

\subsection {Representation of a homotopy equivalence}

A homotopy equivalence\index{homotopy equivalence!representation} is implemented as an instance
of the {\tt CLOS}  class {\tt HOMOTOPY-EQUIVALENCE}\index{class!{\tt HOMOTOPY-EQUIVALENCE}},
whose definition is
{\footnotesize\begin{verbatim}
(DEFCLASS HOMOTOPY-EQUIVALENCE ()
     ;; Left Bottom Chain Complex
    ((lbcc :type chain-complex :initarg :lbcc :reader lbcc1)
     ;; Top Chain Complex
     (tcc  :type chain-complex :initarg :tcc  :reader tcc1)
     ;; Bottom Right Chain Complex
     (rbcc :type chain-complex :initarg :rbcc :reader rbcc1)
     ;; Left f
     (lf   :type morphism      :initarg :lf   :reader lf1)
     ;; Left g
     (lg   :type morphism      :initarg :lg   :reader lg1)
     ;; Left h
     (lh   :type morphism      :initarg :lh   :reader lh1)
     ;; Right f
     (rf   :type morphism      :initarg :rf   :reader rf1)
     ;; Right g
     (rg   :type morphism      :initarg :rg   :reader rg1)
     ;; Right h
     (rh   :type morphism      :initarg :rh   :reader rh1)
     ;; Left ReDuCTion
     (lrdct :type reduction    :initarg :lrdct :reader lrdct)
     ;; Right ReDuCTion
     (rrdct :type reduction    :initarg :rrdct :reader rrdct)
     ;; IDentification NuMber
     (idnm :type fixnum :initform (incf *idnm-counter*) :reader idnm)
     (orgn :type list          :initarg :orgn :reader orgn)))
\end{verbatim}}
%\newpage
This class has  $13$  slots:
\begin{enumerate}
\item {\tt lbcc}, the object of type {\tt chain complex}  representing the chain complex $C$
(\b left \b bottom \b chain \b complex on the diagram).
\item {\tt tcc},  the object of type {\tt chain complex}  representing the chain complex $\hat C$
(\b top \b chain \b complex).
\item {\tt rbcc}, the object of type {\tt chain complex}  representing the chain complex $EC$
(\b right \b bottom \b chain \b complex on the diagram).
\item {\tt lf}, the object of type {\tt morphism}  representing the morphism $f$ of the (\b left) reduction $\rho_1$.
\item {\tt lg}, the object of type {\tt morphism}  representing the morphism $g$ of the (\b left) reduction $\rho_1$.
\item {\tt lh}, the object of type {\tt morphism}  representing the morphism $h$ of the (\b left) reduction $\rho_1$.
\item {\tt rf}, the object of type {\tt morphism}  representing the morphism $f$ of the (\b right) reduction $\rho_2$.
\item {\tt rg}, the object of type {\tt morphism}  representing the morphism $g$ of the (\b right) reduction $\rho_2$.
\item {\tt rh}, the object of type {\tt morphism}  representing the morphism $h$ of the (\b right) reduction $\rho_2$.
\item {\tt lrdc},  the object of type {\tt reduction}  representing the  (\b left) reduction $\rho_1$.
\item {\tt rrdc},  the object of type {\tt reduction}  representing the (\b right) reduction $\rho_2$.
\item {\tt idn}, an integer, number plate for the object, set by the system.
\item {\tt orgn}, an adequate comment list.
\end{enumerate}
When an instance is created, the  printing method associated to the class {\tt HOMOTOPY EQUIVALENCE}
prints a string like {\tt [K{\em n} Homotopy-Equivalence]}, where {\em n} is the number plate of the Kenzo object.
%\newpage

\subsection {The function build-hmeq}

To facilitate\index{function!{\tt build-hmeq}} the construction of instances of the
{\tt HOMOTOPY-EQUIVALENCE} class, the software provides the function, (in fact a method),  {\tt build-hmeq}
which may be used in the following ways:
either with the two reductions $\rho_1$ and $\rho_2$ or explicitly with the morphisms.
The selection of the adequate method is done by inspecting the first keyword, which is
{\tt :lrdct} in the first case and {\tt :lf} in the second one. In both cases
the returned value is an instance of the class {\tt HOMOTOPY-EQUIVALENCE}.
\vskip 0.35cm
1) {\tt build-hmeq :lrdct} {\em lrdct} {\tt :rrdct} {\em rrdc} {\tt :orgn} {\em orgn} \hfill {\em [Method]}
\vskip 0.35cm
The keyword arguments are:
\begin{itemize}
\item[--] {\em lrdct}, the object of type {\tt reduction}  representing the reduction $\rho_1$.
\item[--] {\em rrdct}, the object of type {\tt reduction}  representing the reduction $\rho_2$.
\item[--] {\em org}, the comment list.
\end{itemize}
The function {\tt build-heq-from-rdc} calls internally the standard constructor {\tt make-instance}.
All the needed information is contained in the two reductions.
\vskip 0.35cm
2) {\tt build-hmeq :lf} {\em lf} {\tt :lg} {\em lg}{\tt :lh} {\em lh}{\tt :rf} {\em rf}
                             {\tt :rg} {\em rg}{\tt :rh} {\em rh} {\tt :orgn} {\em orgn} \hfill {\em [Method]}
\vskip 0.35cm
The keyword arguments are:
\begin{itemize}
\item[--] {\em lf}, the  object of type {\tt morphism}  representing the morphism $f$ of the reduction $\rho_1$.
\item[--] {\em lg}, the  object of type {\tt morphism}  representing the morphism $g$ of the reduction $\rho_1$.
\item[--] {\em lh}, the object of type  {\tt morphism}  representing the morphism $h$ of the reduction $\rho_1$.
\item[--] {\em rf}, the object of type {\tt morphism}   representing the morphism $f$ of the reduction $\rho_2$.
\item[--] {\em rg}, the object of type {\tt morphism}   representing the morphism $g$ of the reduction $\rho_2$.
\item[--] {\em rh}, the object of type {\tt morphism}   representing the morphism $h$ of the reduction $\rho_2$.
\item[--] {\em org}, the comment list.
\end{itemize}
All the needed information is contained in the morphism structures.
In both cases, the method  pushes the created instance onto the list {\tt *hmeq-list*}.

\subsection {Useful macros and functions}

{\parindent=0mm
{\leftskip=5mm
{\tt cat-init} \hfill {\em [Function]} \par}
{\leftskip=15mm
Clear among others, the list {\tt *hmeq-list*}, list of user created homotopy equivalences  and reset
the global counter to $1$. \par}
{\leftskip=5mm
{\tt hmeq} {\em n} \hfill {\em [Function]} \par}
{\leftskip=15mm
Retrieve in the list {\tt *hmeq-list*} the  homotopy equivalence  instance whose identification
is $n$. If it does not exist, return {\tt NIL}. \par}
{\leftskip=5mm
{\tt lbcc} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the left bottom chain complex of the homotopy equivalence. Otherwise, it applies  the differential
of the left bottom chain complex of  {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt rbcc} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the right bottom chain complex of the homotopy equivalence. Otherwise, it applies  the differential
of the right  bottom chain complex of  {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt lf} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $f$ of the left reduction of {\em hmeq}. Otherwise, it applies  the morphism $f$
of the left reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt lg} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $g$ of the left reduction of {\em hmeq}. Otherwise, it applies  the morphism $g$
of the left reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt lh} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $h$ of the left reduction of {\em hmeq}. Otherwise, it applies  the morphism $h$
of the left reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt rf} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $f$ of the right reduction of {\em hmeq}. Otherwise, it applies  the morphism $f$
of the right reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt rg} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $g$ of the right reduction of {\em hmeq}. Otherwise, it applies  the morphism $g$
of the right reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt rh} {\em hmeq {\tt \&rest} args} \hfill {\em [Macro]} \par}
{\leftskip=15mm
With only one argument (a homotopy equivalence {\em hmeq}) this macro selects
the morphism $h$ of the right reduction of {\em hmeq}. Otherwise, it applies  the morphism $h$
of the right reduction of {\em hmeq} on the arguments {\em args},
(either {\em degree generator} or {\em cmb}).  \par}
{\leftskip=5mm
{\tt trivial-hmeq} {\em chcm}\hfill {\em [Function]} \par}
{\leftskip=15mm
Build the trivial homotopy equivalence involving only the chain complex {\em chcm}. In that case,
the $3$ chain complexes $C$, $EC$ and $\hat C$ are  the chain complex {\em chcm} itself and
the reductions $\rho_1$ and $\rho_2$ are, of course, the trivial reductions on {\em chcm} built
by the statement {\tt (trivial-rdct {\em chcm})}. \par}
}

\section {The perturbation lemma machinery}

For\index{perturbation lemma} a good understanding of the lisp functions involved in the machinery in question,
we recall the {\em perturbation lemma}\footnote{{\bf Ronald Brown}. {\em The twisted Eilenberg--Zilber theorem}.
Celebrazioni Arch. Secolo XX Simp. Top., 1967, pp 34-37.}. In the basic (resp. trivial) perturbation lemma,
the given perturbation concerns the {\bf top} (resp. {\bf bottom}) chain complex.

\begin{thr}
{\em \bf (Basic perturbation lemma)} --- Let
$\rho=(\hat{C},C,f,g,h)$ a reduction and $\hat{\delta}$ a {\em perturbation} of
$d_{\hat{C}}$, that is, an operator defined on $\hat{C}$ of degree -1 satisfying
the relation $(d_{\hat{C}}+\hat{\delta})\circ(d_{\hat{C}}+\hat{\delta})=0$.
Furthermore, the composite function $h\circ\hat{\delta}$ is assumed {\em
locally nilpotent}, that is, $\forall x \in \hat{C}$,
$(h\circ\hat{\delta})^nx=0$, for $n$ sufficiently large. Then a new reduction
$\rho'=(\hat{C}',C',f',g',h')$ can be constructed where:
\begin{quotation}

\noindent 1) $\hat{C}'$ is the chain complex obtained from $C$ by replacing the old
differential $d_{\hat{C}}$ by $(d_{\hat{C}}+\hat{\delta}),$

\noindent 2) the new chain complex $C'$ is obtained from the chain complex $C$ only by
replacing  the old differential $d_C$ by $(d_C + \delta),$
with $\delta = f \circ {\hat \delta} \circ \phi \circ g =
               f \circ \psi \circ {\hat \delta} \circ g,$

\noindent 3) $f'= f \circ \psi = f \circ (Id - {\hat \delta} \circ \phi \circ h),$

\noindent 4) $g'= \phi \circ g,$

\noindent 5) $h'= \phi \circ h = h \circ \psi$,
\end{quotation}
with
$$\phi=\sum_{i=0}^{\infty}{(-1)^i(h \circ  \hat{\delta})^i}$$
and
$$\psi=\sum_{i=0}^{\infty}{(-1)^i(\hat{\delta}\circ h)^i} = Id - {\hat \delta} \circ \phi \circ h,$$
the convergence being ensured by the locally nilpotency of
$h \circ \hat{\delta}$ and $\hat{\delta} \circ h$.
\end{thr}
\vskip 0.45cm
\begin{thr}
{\em \bf (Trivial perturbation lemma)} --- Let
$\rho=(\hat{C},C,f,g,h)$ a reduction and ${\check\delta}$ a {\em perturbation} of
$d_C$, that is, an operator defined on $C$ of degree -1 satisfying
the relation $(d_C+{\check\delta})\circ (d_C+{\check\delta})=0$.
Then a new reduction $\rho'=(\hat{C}',C',f',g',h')$ can be constructed where:
\begin{quotation}

\noindent 1) $\hat{C}'$ is the chain complex obtained from $C$ by replacing the old
differential $d_{\hat{C}}$ by $(d_{\hat{C}}+ g \circ {\check\delta} \circ f),$

\noindent 2) the new chain complex $C'$ is obtained from the chain complex $C$ only by
replacing  the old differential $d_C$ by $(d_C +{\check \delta}),$

\noindent 3) $f'= f,$

\noindent 4) $g'= g,$

\noindent 5) $h'= h.$
\end{quotation}
\end{thr}

\subsection {Useful functions related to the pertubation lemma}

The functions implementing the perturbation-lemma are
actually the heart of the program. They allow us
to implement the effective versions of the classical spectral sequences
(Serre, Eilenberg-Moore, ...).
\vskip 0.35cm
{\parindent=0mm
{\leftskip=5mm
{\tt add} {\em rdct perturbation} \hfill {\em [Method]} \par}
{\leftskip=15mm
Build a new reduction from the  object of type {\tt reduction}, {\em rdct} and
the  object of type {\tt morphism},  {\em perturbation},
applying the formulas given in the perturbation lemma. In fact, this
method calls  one or the other of the two following functions according as the perturbation is on the top
or on the bottom chain complex and returns the values of the called function. \par}
{\leftskip=5mm
{\tt basic-perturbation-lemma} {\em reduction top-perturbation}\hfill {\em [Function]} \par}
{\leftskip=15mm
Return a double value: the perturbed reduction and the computed bottom-perturbation (a morphism)
$f \circ {\hat \delta}\circ  \phi \circ g$. Of course, to avoid unuseful computations when the morphisms
are effectively applied, the function takes in account the simplifications involved for instance when
some morphisms are the null morphism. \par}
{\leftskip=5mm
{\tt easy-perturbation-lemma} {\em reduction bottom-perturbation} \hfill {\em [Function]} \par}
{\leftskip=15mm
Return a double value: the perturbed reduction and the computed top-perturbation (a morphism)
$g \circ {\check \delta} \circ f$. Of course, to avoid unuseful computation when the morphisms
will be applied, the function takes in account the simplifications involved for instance when
some morphisms are the null morphism. \par}
{\leftskip=5mm
{\tt special-bpl} {\em reduction top-perturbation} \hfill {\em [Function]} \par}
{\leftskip=15mm
This function is analogous to {\tt basic-perturbation-lemma} and is used in some special cases
when the morphism $g$ is invariant. \par}
{\leftskip=5mm
{\tt bpl-*-sigma} {\em  homotopy perturbation} \hfill {\em [Function]} \par}
{\leftskip=15mm
Construct the principal series
$\phi=\sum_{i=0}^{\infty}{(-1)^i(h \circ  \hat{\delta})^i}$ of the basic
perturbation lemma. \par}
{\leftskip=5mm
{\tt add} {\em  hmeq lb-perturbation} \hfill {\em [Method]} \par}
{\leftskip=15mm
Build a homotopy equivalence from the {\tt homotopy-equivalence} {\em hmeq} and
the {\tt morphism} {\em lb-perturbation}, a perturbation  of the differential
of the left bottom chain complex of {\em hmeq}. From {\em hmeq}:
$$\diagram{
  & \hat{C} \cr
 \rho_1\swarrow\nearrow   & & \nwarrow\searrow \rho_2 \cr
C  & & EC \cr }
$$
the method {\tt add} builds the new homotopy equivalence:
$$\diagram{
  & \hat{C}' \cr
 \rho'_1\swarrow\nearrow   & & \nwarrow\searrow \rho'_2 \cr
C'  & & EC' \cr }
$$
where the  construction steps are the following:
\par}
{\leftskip=20mm
-- The reduction $\rho'_1$ is computed with the  method {\tt add} for a reduction with arguments:
the left  reduction of {\em hmeq} and the perturbation {\em lb-perturbation}.
The trivial perturbation lemma is applied.
As a bonus, this returns also the top perturbation, say $\delta$ to be applied to $\hat{C}$.

-- The reduction $\rho'_2$ is computed with the previous method {\tt add} with arguments: the right reduction
of {\em hmeq} and the top perturbation $\delta$ just computed. That time, the basic
perturbation lemma is applied.

-- The function {\tt build-hmeq} is called with parameters $\rho'_1$ and $\rho'_2$. \par}
}

\subsection* {Example}

We shall apply these methods and functions in the following chapters. Let us show on a trivial example
how this machinery works. First, we build a trivial homotopy equivalence on $\Delta^4$. Then we build
a new one by perturbing the differential of the left bottom chain complex with its opposite. The last call
shows how this perturbation has been propagated.
{\footnotesize\begin{verbatim}
(setf hmeq (trivial-hmeq (cdelta 4)))  ==>

[K6 Homotopy-Equivalence]

(setf hmeq (add hmeq (opps (dffr (cdelta 4)))))  ==>

[K14 Homotopy-Equivalence]

(gnrt-? (dffr (rbcc hmeq)) 3 '(0 1 2 3)))  ==>

----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------
\end{verbatim}}

\newpage

\section {Bicones}

Given\index{bicones} $3$ chain complexes $B$, $C$ and $D$, together with $2$
chain homomorphisms $f_1$ and $f_2$ of degree $0$ (commuting with the differentials),
as shown in the following diagram, a bicone on these chain complexes is a chain
complex, $BCN(f_1,f_2)$ where the $n$-th chain group $[BCN(f_1,f_2)]$ is $B_n \oplus C_{n+1} \oplus D_n$.
$$
\begin{array}{l}
\hspace{4pt}B \hspace{32pt} D \\
\hspace{1pt} \raisebox{3pt}{$f_1$} \searrow \hspace{12pt}
             \swarrow \raisebox{3pt}{$f_2$} \\
\hspace{30pt} C
\end{array}
$$


\subsection {Representation of a combination in a bicone.}

To distinguish to which chain complex belongs a generator in a combination of a bicone, the following convention
has been adopted: if {\tt gb} is a generator of any degree of $B$, it will be represented in the bicone
by the list {\tt (:BcnB gb)} and printed as {\tt <BcnB gb>}. The symbols for $C$ and $D$ are respectively
{\tt :BcnC} and {\tt :BcnD}. The $3$ macros {\tt bcnb}, {\tt bcnc} and {\tt bcnd} may be used to build
such a generator. The building function for combinations,  {\tt cmbn}, may be used in the following way:
{\footnotesize\begin{verbatim}
(setf comb-bic (cmbn 3 2 (bcnb 'b1) 4 (bcnb 'b2) 6 (bcnb 'b3)
                       3 (bcnc 'c1) 5 (bcnc 'c2) 7 (bcnd 'd1)))

----------------------------------------------------------------------{CMBN 3}
<2 * <BcnB B1>>
<4 * <BcnB B2>>
<6 * <BcnB B3>>
<3 * <BcnC C1>>
<5 * <BcnC C2>>
<7 * <BcnD D1>>
------------------------------------------------------------------------------

(cmbn-list comb-bic)  ==>

((2 :BCNB . B1) (4 :BCNB . B2) (6 :BCNB . B3)
 (3 :BCNC . C1) (5 :BCNC . C2) (7 :BCND . D1))
\end{verbatim}}

\newpage

\subsection {Useful functions and macros for bicones}

{\parindent=0mm
{\leftskip=5mm
{\tt bcnb} {\em gnrt} \hfill {\em [Macro]} \par}
{\leftskip=15mm
Build the representation of the generator {\em gnrt} belonging to the chain complex
$B$. \par}{\leftskip=5mm
{\tt bcnc} {\em gnrt} \hfill {\em [Macro]} \par}
{\leftskip=15mm
Build the representation of the generator {\em gnrt} belonging to the chain complex
$C$. \par}{\leftskip=5mm
{\tt bcnd} {\em gnrt} \hfill {\em [Macro]} \par}
{\leftskip=15mm
Build the representation of the generator {\em gnrt} belonging to the chain complex
$D$. \par}
{\leftskip=5mm
{\tt make-bicn-cmbn} {\em cmbnb cmbnc cmbnd} \hfill {\em [Function]} \par}
{\leftskip=15mm
Build a bicone combination from the $3$ combinations {\em cmbnb}, {\em cmbnc} and {\em cmbnd} belonging
respectively and in that order to $B$, $C$ and $D$. The degrees of the combinations {\em cmbnb} and {\em cmbnd}
must be the same, say $n$. The degree of {\em cmbnc} must be $n+1$. The degree of the new created combination
is $n$. \par }
{\leftskip=5mm
{\tt bicn-cmbn-cmbnb} {\em cmbn} \hfill {\em [Function]} \par}
{\leftskip=15mm
Extract from the bicone combination of degree $n$, {\em cmbn}, the combination relative to $B$ as a legal combination
of degree $n$ in $B$. If there is no $B$-component, return the null combination of degree $n$. \par}
{\leftskip=5mm
{\tt bicn-cmbn-cmbnc} {\em cmbn} \hfill {\em [Function]} \par}
{\leftskip=15mm
Extract from the bicone combination of degree $n$, {\em cmbn}, the combination relative to $C$ as a legal combination
of degree $n+1$ in $C$. If there is no $C$-component, return the null combination of degree $n+1$. \par}
{\leftskip=5mm
{\tt bicn-cmbn-cmbnd} {\em cmbn} \hfill {\em [Function]} \par}
{\leftskip=15mm
Extract from the bicone combination of degree $n$, {\em cmbn}, the combination relative to $D$ as a legal combination
of degree $n$ in $D$. If there is no $D$-component, return the null combination of degree $n$. \par}
{\leftskip=5mm
{\tt dispatch-bicn-cmbn} {\em cmbn} \hfill {\em [Function]} \par}
{\leftskip=15mm
Give the $3$-values result constitued by the $3$ combinations components of the bicone combination
{\em cmbn}. These combinations are valid combinations in their respective chain complexes. \par}
}

\newpage

\subsection* {Examples}

{\footnotesize\begin{verbatim}
(setf comb-b (cmbn 3 2 'b1 4 'b2 6 'b3)) ==>

----------------------------------------------------------------------{CMBN 3}
<2 * B1>
<4 * B2>
<6 * B2>
------------------------------------------------------------------------------

(setf comb-c (cmbn 4 3 'c1 5 'c2))  ==>

----------------------------------------------------------------------{CMBN 4}
<3 * C1>
<5 * C2>
------------------------------------------------------------------------------

(setf comb-d (cmbn 3 7 'd1))  ==>

----------------------------------------------------------------------{CMBN 3}
<7 * D1>
------------------------------------------------------------------------------

(setf comb-bic (make-bicn-cmbn comb-b comb-c comb-d))  ==>

----------------------------------------------------------------------{CMBN 3}
<2 * <BcnB B1>>
<4 * <BcnB B2>>
<6 * <BcnB B3>>
<3 * <BcnC C1>>
<5 * <BcnC C2>>
<7 * <BcnD D1>>
------------------------------------------------------------------------------

(bicn-cmbn-cmbnb comb-bic)  ==>

----------------------------------------------------------------------{CMBN 3}
<2 * B1>
<4 * B2>
<6 * B2>
------------------------------------------------------------------------------

(bicn-cmbn-cmbnc comb-bic)  ==>

----------------------------------------------------------------------{CMBN 4}
<3 * C1>
<5 * C2>
------------------------------------------------------------------------------

(bicn-cmbn-cmbnd comb-bic)  ==>

----------------------------------------------------------------------{CMBN 3}
<7 * D1>
------------------------------------------------------------------------------

(dispatch-bicn-cmbn comb-bic)  ==>

----------------------------------------------------------------------{CMBN 3}
<2 * B1>
<4 * B2>
<6 * B2>
------------------------------------------------------------------------------

----------------------------------------------------------------------{CMBN 4}
<3 * C1>
<5 * C2>
------------------------------------------------------------------------------

----------------------------------------------------------------------{CMBN 3}
<7 * D1>
------------------------------------------------------------------------------
\end{verbatim}}

\section {Construction of a bicone from 2 reductions.}

From\index{bicones!construction} the slots of the respective chain complexes $B$, $C$ and $D$, it is possible to
build the bicone chain complex. The $3$ essential functions are the following:
\vskip 0.45cm
{\parindent=0mm
{\leftskip=5mm
{\tt bicone-cmpr} {\em cmprb cmprc cmprd} \hfill {\em [Function]} \par}
{\leftskip=15mm
From the $3$ comparison functions {\em cmprb}, {\em cmprc} and {\em cmprd}, build a
comparison function adequate to compare the generators as represented in the bicone. \par}
{\leftskip=5mm
{\tt bicone-basis} {\em basisb basisc basisd} \hfill {\em [Function]} \par}
{\leftskip=15mm
From the $3$ basis function {\em basisb}, {\em basisc} and {\em basisd}, build a
basis function for the bicone. If at least one of the chain complex component of
the bicone is {\em locally effective}, the function returns the symbol {\tt :locally-effective}. \par}
{\leftskip=5mm
{\tt bicone-intr-dffr } {\em cmprc dffrb dffrc dffrd f1 f2} \hfill {\em [Function]} \par}
{\leftskip=15mm
Define the differential in the bicone according to the formula:
$$d(cb, cc, cd)= (d_B(cb), f_1(cb) + f_2(cd) - d_C(cc), d_D(cd)),$$
where the notation is self explanatory. One sees that one needs the comparison operator
{\em cmprc} of $C$, to order correctly the second combination of the resulting triple. \par}
}
\vskip 0.35cm
Let us consider now $2$ reductions $(\hat C_1, C_1, f1, g1, h1)$ and $(\hat C_2, C_2, f2, g2, h2)$
in which $C_1 = C_2$. It is possible to define a bicone, with the identification
$\hat C_1=B, C_1=C_2=C, \hat C_2=D$. This is realised by the  following function:
\vskip 0.35cm
{\parindent=0mm
{\leftskip=5mm
{\tt bicone} {\em rdct1 rdct2} \hfill {\em [Function]} \par}
{\leftskip=15mm
Build the bicone chain complex from the objects ot type {\tt reduction} {\em rdct1} and {\em rdct2}.
The bicone is built with the following identification: $B$ is the top chain complex of {\em rdct1},
$D$ is the top chain complex of {\em rdct2}. The bottom chain complexes of both {\em rdct1} and {\em rdct2}
must be the same and $C$ is  that chain complex. Of course, both chain morphisms $f_1$ and
$f_2$ are respectively the morphism $f$ of the reductions. The construction of the bicone is realised
by a call to the building function {\tt build-chcm} using the $3$ functions {\tt bicone-cmpr},
{\tt bicone-basis} and {\tt bicone-intr-dffr} with arguments coming from {\em rdct1} an {\em rdct2}.
The slot {\tt bsgn} (base point) is let undefined and the strategy is by combination. \par}

\subsection* {Example}

Let us take again the example with the standard simplex $\Delta^n$. The following function
defines an effective version of ${\cal C}_*(\Delta^n)$, so we may ask for the basis in some dimensions.
{\footnotesize\begin{verbatim}
 (defun cdelta (dmns)
     (build-chcm
        :cmpr #'l-cmpr
        :basis #'(lambda (n)
                    (mapcar #'dlop-int-ext (funcall (delta-n-basis dmns) n)))
        :bsgn '(0)
        :intr-dffr #'(lambda (degr gmsm)
                        (make-cmbn
                           :degr (1- degr)
                           :list (do ((rslt +empty-list+
                                           (cons (cons sign
                                                      (append
                                                        (subseq gmsm 0 nark)
                                                        (subseq gmsm (1+ nark))))
                                                  rslt))
                                     (sign 1 (- sign))
                                     (nark 0 (1+ nark)))
                                    ((> nark degr) rslt))))
        :strt :gnrt
        :orgn `(Effective version of C_* delta ,dmns)))


(setf delta3 (cdelta 3))  ==>

[K1 Chain-Complex]

(basis delta3 0)  ==>

((0) (1) (2) (3))

(basis delta3 1)  ==>

((0 1) (0 2) (1 2) (0 3) (1 3) (2 3))

(basis delta3 2)  ==>

((0 1 2) (0 1 3) (0 2 3) (1 2 3))

(basis delta3 3)  ==>

((0 1 2 3))

(basis delta3 4)  ==>

NIL
\end{verbatim}}
Using the function {\tt make-rdct} defined in previous example which builds a reduction between
$\Delta^m$ and $\Delta^n$, we may
create a bicone chain complex with the function {\tt bicone} and ask for basis in some dimensions.
{\footnotesize\begin{verbatim}
(setf bic (bicone (make-rdct 3 2)(make-rdct 4 2)))  ==>

[K15 Chain-Complex]

(basis bic 0)  ==>

(<BcnB (0)> <BcnB (1)> <BcnB (2)> <BcnB (3)>
 <BcnC (0 1)> <BcnC (0 2)> <BcnC (1 2)>
 <BcnD (0)> <BcnD (1)> <BcnD (2)> <BcnD (3)> <BcnD (4)>)

(basis bic 1)  ==>

(<BcnB (0 1)> <BcnB (0 2)> <BcnB (1 2)> <BcnB (0 3)> <BcnB (1 3)> <BcnB (2 3)>
 <BcnC (0 1 2)>
 <BcnD (0 1)> <BcnD (0 2)> <BcnD (1 2)> <BcnD (0 3)> <BcnD (1 3)> <BcnD (2 3)>
 <BcnD (0 4)> <BcnD (1 4)> <BcnD (2 4)> <BcnD (3 4)>)

(basis bic 4)  ==>

(<BcnD (0 1 2 3 4)>)
\end{verbatim}}
We verify the validity of the differential in the bicone {\tt bic}.
{\footnotesize\begin{verbatim}
(? bic (cmbn 2 3 (bcnb '(0 1 3)) 4 (bcnc '(0 1 2 3)) 5 (bcnd '(0 1 4))))  ==>

----------------------------------------------------------------------{CMBN 1}
<3 * <BcnB (0 1)>>
<-3 * <BcnB (0 3)>>
<3 * <BcnB (1 3)>>
<12 * <BcnC (0 1 2)>>
<-4 * <BcnC (0 1 3)>>
<4 * <BcnC (0 2 3)>>
<-4 * <BcnC (1 2 3)>>
<5 * <BcnD (0 1)>>
<-5 * <BcnD (0 4)>>
<5 * <BcnD (1 4)>>
------------------------------------------------------------------------------

(? bic *)  ==>

----------------------------------------------------------------------{CMBN 0}
------------------------------------------------------------------------------
\end{verbatim}}

\section {Composition of homotopy equivalences.}

Let\index{homotopy equivalence!composition} us consider $2$ homotopy equivalences, as in the following diagram.
$$\diagram{
  & B  & & & D & & \cr
 \rho_1 \swarrow\nearrow  & & \nwarrow\searrow \rho_2 & \rho'_1\swarrow\nearrow & & \nwarrow\searrow\rho'_2 & \cr
A  & &  C & C   & & E \cr
           }$$
where the right bottom complex of the first one is the same as the left bottom reduction
of the second.
We may use then the bicone concept
to build a bicone chain complex with $B$, $C$ and $D$, say $BCN$, and finally build
a new homotopy equivalence between $A$, $BCN$ and $E$.
$$\diagram{
  & BCN \cr
 \rho''_1 \swarrow\nearrow  & & \nwarrow\searrow \rho''_2 \cr
A  & &  E \cr
          }$$

This is realized by the method {\tt cmps}.
\vskip 0.35cm
{\parindent=0mm
{\leftskip=5mm
{\tt cmps} {\em hmeq1 hmeq2} \hfill {\em [Method]} \par}
{\leftskip=15mm
Build a homotopy equivalence by composition of both homotopy equivalences {\em hmeq1}, {\em hmeq2}.
The system controls the validity of the composition. \par}
}

\subsection* {Example}

Starting with a very simple chain complex and the trivial homotopy equivalence
on the chain complex, we verify the correctness of various compositions.
The chain complex {\tt c} has only one vertex {\tt (a)} in every dimension and the
differential is the null morphism.
{\footnotesize \begin{verbatim}
(setf c (build-chcm
             :cmpr #'s-cmpr
             :basis #'(lambda (dmns) '(a))
             :bsgn 'a
             :intr-dffr #'zero-intr-dffr
             :strt :cmbn
             :orgn '(c)))  ==>

[K1 Chain-Complex]
\end{verbatim}}
We build the trivial homotopy equivalence on {\tt c} and we compose it with itself.
{\footnotesize \begin{verbatim}
(setf h1 (trivial-hmeq c))  ==>

[K6 Homotopy-Equivalence]

(setf h2 (cmps h1 h1))  ==>

[K17 Homotopy-Equivalence]
\end{verbatim}}
We verify the coherency of the morphisms in the left and right reduction
of {\tt h2}. The combination {\tt *tc*} must belong to a bicone whereas
{\tt *bc*} belongs to {\tt c}.
{\footnotesize \begin{verbatim}
(pre-check-rdct (lrdct h2))  ==>

---done---

(setf *tc* (cmbn 3 1 (bcnB 'a) 10 (bcnC 'a) 100 (bcnD 'a)))  ==>

----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB A>>
<10 * <BcnC A>>
<100 * <BcnD A>>
------------------------------------------------------------------------------

(setf *bc* (cmbn 3 1 'a))  ==>

----------------------------------------------------------------------{CMBN 3}
<1 * A>
------------------------------------------------------------------------------

(check-rdct)  ==>

*TC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB A>>
<10 * <BcnC A>>
<100 * <BcnD A>>
------------------------------------------------------------------------------

*BC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * A>
------------------------------------------------------------------------------

Checking *TDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *BDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

Checking *DF-FD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------
\end{verbatim}}
\newpage
{\footnotesize \begin{verbatim}
Checking *DG-GD* = 0
Result:
----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------

Checking *ID-FG* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------

Checking *ID-GF-DH-HD* = 0
Result:
----------------------------------------------------------------------{CMBN 3}
------------------------------------------------------------------------------

Checking *HH* = 0
Result:
----------------------------------------------------------------------{CMBN 5}
------------------------------------------------------------------------------

Checking *FH* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---

(pre-check-rdct (rrdct h2))  ==>

---done---

(check-rdct)  ==>

*TC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB A>>
<10 * <BcnC A>>
<100 * <BcnD A>>
------------------------------------------------------------------------------
\end{verbatim}}
\newpage
{\footnotesize \begin{verbatim}
*BC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * A>
------------------------------------------------------------------------------

Checking *TDD* = 0

----------------------------------------------------------------------{CMBN 2}
------------------------------------------------------------------------------

............ all results NULL...........

Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---
\end{verbatim}}
We compose now {\tt h2} with itself. We let {\tt *bc*} unchanged, but {\tt *tc*}
is a little more complicated because the chain complexes $B$ and $D$  are themselves  bicones.
{\footnotesize\begin{verbatim}
(setf h3 (cmps h2 h2))  ==>

[K65 Homotopy-Equivalence]

(setf *tc* (cmbn 3 1 (bcnB (bcnB 'a)) 10 (bcnB (bcnC 'a)) 100 (bcnB (bcnD 'a))
                      1000 (bcnC 'a)
                     10000 (bcnD (bcnB 'a)) 5234 (bcnD (bcnC 'a))
                       223 (bcnD (bcnD 'a))))  ==>
----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB <BcnB A>>>
<10 * <BcnB <BcnC A>>>
<100 * <BcnB <BcnD A>>>
<1000 * <BcnC A>>
<10000 * <BcnD <BcnB A>>>
<5234 * <BcnD <BcnC A>>>
<223 * <BcnD <BcnD A>>>
------------------------------------------------------------------------------

(pre-check-rdct (lrdct h3))  ==>

---done---

(check-rdct)  ==>

*TC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB <BcnB A>>>
<10 * <BcnB <BcnC A>>>
<100 * <BcnB <BcnD A>>>
<1000 * <BcnC A>>
<10000 * <BcnD <BcnB A>>>
<5234 * <BcnD <BcnC A>>>
<223 * <BcnD <BcnD A>>>
------------------------------------------------------------------------------

*BC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * A>
------------------------------------------------------------------------------

Checking *TDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

............ all results NULL...........

Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---

(pre-check-rdct (rrdct h3))  ==>

---done---

(check-rdct)  ==>


*TC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * <BcnB <BcnB A>>>
<10 * <BcnB <BcnC A>>>
<100 * <BcnB <BcnD A>>>
<1000 * <BcnC A>>
<10000 * <BcnD <BcnB A>>>
<5234 * <BcnD <BcnC A>>>
<223 * <BcnD <BcnD A>>>
------------------------------------------------------------------------------

*BC* =>
----------------------------------------------------------------------{CMBN 3}
<1 * A>
------------------------------------------------------------------------------

Checking *TDD* = 0
Result:
----------------------------------------------------------------------{CMBN 1}
------------------------------------------------------------------------------

............ all results NULL...........

Checking *HG* = 0
Result:
----------------------------------------------------------------------{CMBN 4}
------------------------------------------------------------------------------

---done---
\end{verbatim}}

\subsection* {Lisp files concerned in this chapter}


{\tt effective-homology.lisp}, {\tt cones.lisp}.
\par
[{\tt classes.lisp }, {\tt macros.lisp}, {\tt various.lisp}].
