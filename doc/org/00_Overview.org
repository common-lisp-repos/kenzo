#+TITLE: Overview
#+OPTIONS: toc:nil num:t
#+PROPERTY: header-args :eval never-export :exports both :tangle yes

#+BEGIN_SRC lisp :exports none :results silent
(ql:quickload "kenzo")
(use-package :cat)
#+END_SRC

Let us begin by the space $\mathrm{Moore}(\mathbb{Z}/2\mathbb{Z}, 3)$
described as a simplicial set having only three non-degenerate simplices,
namely in dimension $0$, $3$ and $4$. In the representation created by the
software, the 0-simplex (base point), the 3-simplex and the 4-simplex are
respectively labelled =*=, =M3= and =N4=. The faces 0 and 2 of the 4-simplex =N4= are
identified with (pasted to) the 3-simplex =M3=, the others being contracted on
the base point. To create the simplicial set one types simply:

#+BEGIN_SRC lisp :exports none
(defvar m23)
#+END_SRC

#+RESULTS:
: M23

#+BEGIN_SRC lisp
(setf m23 (moore 2 3))
#+END_SRC

#+RESULTS:
: [K1 Simplicial-Set]

The system answers that a Kenzo object has been created, with number 1 and
type =SIMPLICIAL SET=. This object may be referenced by the symbol =m23=.

#+BEGIN_SRC lisp :exports none
m23
#+END_SRC

#+RESULTS:
: [K1 Simplicial-Set]

We may compute the homology groups of this space, using the underlying chain
complex induced by the simplicial set description. Here we compute the $H_i$
from 0 to 4 included. When in the answer the component part is void, it means
that the corresponding homology group is null.

#+BEGIN_SRC lisp :results output
(homology m23 0 5)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 0.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 55s.
Computing the boundary of the generator 1/1 (dimension 0) :
,*
End of computing.


Computing boundary-matrix in dimension 1.
Rank of the source-module : 0.




Homology in dimension 0 :


Component Z


---done---

;; Clock -> 2019-12-15, 22h 27m 55s.


Computing boundary-matrix in dimension 1.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 2.
Rank of the source-module : 0.




Homology in dimension 1 :



---done---

;; Clock -> 2019-12-15, 22h 27m 55s.


Computing boundary-matrix in dimension 2.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 55s.
Computing the boundary of the generator 1/1 (dimension 3) :
M3
End of computing.




Homology in dimension 2 :



---done---

;; Clock -> 2019-12-15, 22h 27m 55s.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 55s.
Computing the boundary of the generator 1/1 (dimension 3) :
M3
End of computing.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 55s.
Computing the boundary of the generator 1/1 (dimension 4) :
N4
End of computing.




Homology in dimension 3 :


Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 55s.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 55s.
Computing the boundary of the generator 1/1 (dimension 4) :
N4
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 0.




Homology in dimension 4 :



---done---

;; Clock -> 2019-12-15, 22h 27m 55s.

#+end_example

The homology of =m23= is  $(\mathbb{Z},0,0,\mathbb{Z}/2,0,\ldots)$; the reduced
homology is only  $\mathbb{Z}/2$  in dimension 3, defining the Moore space up
to homotopy.

As =m23= is a simplicial set, it is possible to create the cartesian product
=m23xm23= by the function =crts-prdc= (= CaRTeSian PRoDuCt). This is a new
simplicial set.

#+BEGIN_SRC lisp :exports none
(defvar m23xm23)
#+END_SRC

#+RESULTS:
: M23XM23

#+BEGIN_SRC lisp
(setf m23xm23 (crts-prdc m23 m23))
#+END_SRC

#+RESULTS:
: [K10 Simplicial-Set]

Being a simplicial set, =m23xm23= is also a chain complex object and we may for
instance ask for the basis in dimension 6.

#+BEGIN_SRC lisp :results verbatim
(basis m23xm23 6)
#+END_SRC

#+RESULTS:
: (<CrPr 1-0 N4 3-2 N4> <CrPr 1-0 N4 4-2 N4> <CrPr 1-0 N4 4-3 N4> <CrPr 1-0 N4 4-3-2 M3> <CrPr 1-0 N4 5-2 N4> <CrPr 1-0 N4 5-3 N4> <CrPr 1-0 N4 5-3-2 M3> <CrPr 1-0 N4 5-4 N4> <CrPr 1-0 N4 5-4-2 M3> <CrPr 1-0 N4 5-4-3 M3> ...)

#+BEGIN_SRC lisp
(length (basis m23xm23 6))
#+END_SRC

#+RESULTS:
: 230

As shown by the last command, the number of elements of the basis is quite
large (230). The user will note that the basis elements are in this
particular case formed by cartesian products of /degenerated simplices/. In the
list, an element like =<CrPr 1-0 N4 5-3-2 M3>= means
$\eta_1\eta_0\mathrm{N4}\times\eta_5\eta_3\eta_2\mathrm{M3}$.

We may construct also the tensor product $\mathrm{m23}\otimes\mathrm{m23}$
from the underlying chain complex of the simplicial set =m23=. The tensor
product of two simplicial sets do not make sense, and Kenzo understands to
work on the underlying chain complex =m23=. This tensor product is a new chain
complex and we see that the basis in dimension 6 has only one element:

#+BEGIN_SRC lisp :exports none
(defvar t2m23)
#+END_SRC

#+RESULTS:
: T2M23

#+BEGIN_SRC lisp
(setf t2m23 (tnsr-prdc m23 m23))
#+END_SRC

#+RESULTS:
: [K3 Chain-Complex]

#+BEGIN_SRC lisp :results verbatim
(basis t2m23 6)
#+END_SRC

#+RESULTS:
: (<TnPr M3 M3>)

The Eilenberg-Zilber theorem is used to compute the homology groups of the
cartesian product space: as chain complexes, =m23xm23= and =t2m23= have the
same homology groups, but the computations using the tensor product are
considerably faster. The user can check KÃ¼nneth's theorem.

#+BEGIN_SRC lisp :results output
(homology m23xm23 0 8)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 0.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/1 (dimension 0) :
<TnPr * *>
End of computing.


Computing boundary-matrix in dimension 1.
Rank of the source-module : 0.




Homology in dimension 0 :


Component Z


---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 1.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 2.
Rank of the source-module : 0.




Homology in dimension 1 :



---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 2.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 3) :
<TnPr * M3>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 3) :
<TnPr M3 *>
End of computing.




Homology in dimension 2 :



---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 3) :
<TnPr * M3>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 3) :
<TnPr M3 *>
End of computing.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 4) :
<TnPr * N4>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 4) :
<TnPr N4 *>
End of computing.




Homology in dimension 3 :


Component Z/2Z

Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 4) :
<TnPr * N4>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 4) :
<TnPr N4 *>
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 0.




Homology in dimension 4 :



---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 6.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/1 (dimension 6) :
<TnPr M3 M3>
End of computing.




Homology in dimension 5 :



---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 6.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/1 (dimension 6) :
<TnPr M3 M3>
End of computing.


Computing boundary-matrix in dimension 7.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 7) :
<TnPr M3 N4>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 7) :
<TnPr N4 M3>
End of computing.




Homology in dimension 6 :


Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 56s.


Computing boundary-matrix in dimension 7.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 7) :
<TnPr M3 N4>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 7) :
<TnPr N4 M3>
End of computing.


Computing boundary-matrix in dimension 8.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/1 (dimension 8) :
<TnPr N4 N4>
End of computing.




Homology in dimension 7 :


Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 56s.

#+end_example

Let us consider now the space $\mathrm{K}(\mathbb{Z}, 1)$. This is an Abelian
simplicial group created  in `Kenzo` by the function =k-z=. In this simplicial
group, a simplex in dimension $n$ is mathematically represented by a sequence
of integers, known as a /bar/ object:
$$ [a_1 \mid a_2 \mid \ldots \mid a_n].$$
In =Kenzo=, a non-degenerate simplex of $\mathrm{K}(\mathbb{Z}, 1)$ in
dimension $n$ will be simply a list of $n$ non-null integers, for instance:
=(2 3 4 5)=. In dimension 0, the only simplex is =NIL= (the base point).

#+BEGIN_SRC lisp :exports none
(defvar kz1)
#+END_SRC

#+RESULTS:
: KZ1

#+BEGIN_SRC lisp
(setf kz1 (k-z 1))
#+END_SRC

#+RESULTS:
: [K38 Abelian-Simplicial-Group]

But this object is also a /coalgebra/ and an /algebra/, and we may see the
effect of the respective induced /coproduct/ and /product/:

#+BEGIN_SRC lisp :results output
(princ (cprd kz1 4 '(2 3 4 5)))
#+END_SRC

#+RESULTS:
:
: ----------------------------------------------------------------------{CMBN 4}
: <1 * <TnPr NIL (2 3 4 5)>>
: <1 * <TnPr (2) (3 4 5)>>
: <1 * <TnPr (2 3) (4 5)>>
: <1 * <TnPr (2 3 4) (5)>>
: <1 * <TnPr (2 3 4 5) NIL>>
: ------------------------------------------------------------------------------

#+BEGIN_SRC lisp :results output
(princ (aprd kz1 6 (tnpr 2 '(1 2) 4 '(3 4 5 6))))
#+END_SRC

#+RESULTS:
#+begin_example

----------------------------------------------------------------------{CMBN 6}
<1 * (1 2 3 4 5 6)>
<-1 * (1 3 2 4 5 6)>
<1 * (1 3 4 2 5 6)>
<-1 * (1 3 4 5 2 6)>
<1 * (1 3 4 5 6 2)>
<1 * (3 1 2 4 5 6)>
<-1 * (3 1 4 2 5 6)>
<1 * (3 1 4 5 2 6)>
<-1 * (3 1 4 5 6 2)>
<1 * (3 4 1 2 5 6)>
... ...
------------------------------------------------------------------------------
#+end_example

The printed results are the printed representation of /combinations/, i.e.,
integer linear combinations of generators resulting from the application of
the morphisms. The degree of the combination is indicated by the information:
=CMBN n=.

In the same way, we may create the Abelian simplicial groups
$\mathrm{K}(\mathbb{Z}/2\mathbb{Z}, n)$:

#+BEGIN_SRC lisp :exports none
(defvar k-z2-2)
#+END_SRC

#+RESULTS:
: K-Z2-2

#+BEGIN_SRC lisp
(setf k-z2-2 (k-z2 2))
#+END_SRC

#+RESULTS:
: [K64 Abelian-Simplicial-Group]

#+BEGIN_SRC lisp :results output
(homology k-z2-2 4)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 4.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/2 (dimension 4) :
<<Abar[4 3]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/2 (dimension 4) :
<<Abar[2 1][2 1]>>
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 3.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 1/3 (dimension 5) :
<<Abar[5 4]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 2/3 (dimension 5) :
<<Abar[2 1][3 2]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 56s.
Computing the boundary of the generator 3/3 (dimension 5) :
<<Abar[3 2][2 1]>>
End of computing.




Homology in dimension 4 :


Component Z/4Z


---done---

;; Clock -> 2019-12-15, 22h 27m 56s.

#+end_example

Let us play now with the sphere $S^3$ and its loop spaces. $S^3$ and
$\Omega^2 S^3$ are created by respective calls to the functions =sphere= and
=loop-space=. Then we compute the $H_4$ and $H_5$ of $\Omega^2 S^3$:

#+BEGIN_SRC lisp :exports none
(defvar s3)
#+END_SRC

#+RESULTS:
: S3

#+BEGIN_SRC lisp
(setf s3 (sphere 3))
#+END_SRC

#+RESULTS:
: [K174 Simplicial-Set]

#+BEGIN_SRC lisp :exports none
(defvar o2s3)
#+END_SRC

#+RESULTS:
: O2S3

#+BEGIN_SRC lisp
(setf o2s3 (loop-space s3 2))
#+END_SRC

#+RESULTS:
: [K191 Simplicial-Group]

#+BEGIN_SRC lisp :results output
(homology o2s3 4 6)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 4.
Rank of the source-module : 3.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 1/3 (dimension 4) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 2/3 (dimension 4) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 3/3 (dimension 4) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 5.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 1/5 (dimension 5) :
<<AlLp[5 <<AlLp[2 S3][2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 2/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 3/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 4/5 (dimension 5) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 5/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.




Homology in dimension 4 :


Component Z/3Z

Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 57s.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 5.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 1/5 (dimension 5) :
<<AlLp[5 <<AlLp[2 S3][2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 2/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 3/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 4/5 (dimension 5) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 5/5 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


Computing boundary-matrix in dimension 6.
Rank of the source-module : 8.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 1/8 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][5 <<AlLp[2 S3][2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 2/8 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 3/8 (dimension 6) :
<<AlLp[5 <<AlLp[2 S3][2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 4/8 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 5/8 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 6/8 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 7/8 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 57s.
Computing the boundary of the generator 8/8 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.




Homology in dimension 5 :


Component Z/3Z

Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 57s.

#+end_example

Let us take now the first loop space $\Omega^1 S^3$

#+BEGIN_SRC lisp :exports none
(defvar os3)
#+END_SRC

#+RESULTS:
: OS3

#+BEGIN_SRC lisp
(setf os3 (loop-space s3))
#+END_SRC

#+RESULTS:
: [K179 Simplicial-Group]

In the following instruction, we locate in the symbol =L1= the canonical
generator of $\pi_2 (\Omega^1S^3)$, that is the 2-simplex coming from the
original sphere. In fact, the object created by the command $\texttt{(loop3 0
's3 1)}$ is the "word" $S3^1$ belonging to the Kan simplicial version
$G(S^3)$ (a simplicial group) of the loop space $\Omega S^3$.

#+BEGIN_SRC lisp :exports none
(defvar L1)
#+END_SRC

#+RESULTS:
: L1

#+BEGIN_SRC lisp :results output
(princ (setf L1 (loop3 0 's3 1)))
#+END_SRC

#+RESULTS:
: <<Loop[S3]>>

Let us consider also the 2-degeneracy of the base point of the loop space. In
the printed result, the user will recognize the degeneracy $\eta_1\eta_0$ of
the null loop, base point of $\Omega^1 S^3$:

#+BEGIN_SRC lisp :exports none
(defvar null-simp)
#+END_SRC

#+RESULTS:
: NULL-SIMP

#+BEGIN_SRC lisp :results output
(princ (setf null-simp (absm 3 +null-loop+)))
#+END_SRC

#+RESULTS:
: <AbSm 1-0 <<Loop>>>

We may build now a new space by pasting a disk $D3$ as indicated by the
following call. It means that we "paste" to the space =os3= a 3-simplex named =D3=,
the attaching map being described by the list of its faces in dimension 2. The
faces 0 and 2 of =D3= are pasted to =L1=, the faces 1 and 3 are collapsed on the
base point; in this way the attaching map $(S^2 \rightarrow \Omega S^3)$ has
degree 2.

#+BEGIN_SRC lisp :exports none
(defvar dos3)
#+END_SRC

#+RESULTS:
: DOS3

#+BEGIN_SRC lisp
(setf dos3 (disk-pasting os3 3 '<D3> (list L1 null-simp L1 null-simp)))
#+END_SRC

#+RESULTS:
: [K435 Simplicial-Set]

Let us compute a few homology groups of the new space =dos3=:

#+BEGIN_SRC lisp :results output
(homology dos3 2 4)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 2.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 58s.
Computing the boundary of the generator 1/1 (dimension 2) :
<<AlLp[2 S3]>>
End of computing.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 58s.
Computing the boundary of the generator 1/1 (dimension 3) :
<D3>
End of computing.




Homology in dimension 2 :


Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 27m 58s.


Computing boundary-matrix in dimension 3.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 58s.
Computing the boundary of the generator 1/1 (dimension 3) :
<D3>
End of computing.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 27m 58s.
Computing the boundary of the generator 1/1 (dimension 4) :
<<AlLp[2 S3][2 S3]>>
End of computing.




Homology in dimension 3 :



---done---

;; Clock -> 2019-12-15, 22h 27m 58s.

#+end_example

But more interesting, let us build the loop space of the object =dos3= and let
us compute the homology in dimension 5:

#+BEGIN_SRC lisp :exports none
(defvar odos3)
#+END_SRC

#+RESULTS:
: ODOS3

#+BEGIN_SRC lisp
(setf odos3 (loop-space dos3))
#+END_SRC

#+RESULTS:
: [K453 Simplicial-Group]

#+BEGIN_SRC lisp :results output
(homology odos3 5)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 5.
Rank of the source-module : 14.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 1/14 (dimension 5) :
<<AlLp[5 <<AlLp[2 S3][2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 2/14 (dimension 5) :
<<AlLp[2 <D3>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 3/14 (dimension 5) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 4/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 5/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 6/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 7/14 (dimension 5) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 8/14 (dimension 5) :
<<AlLp[2 <D3>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 9/14 (dimension 5) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 10/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 11/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 12/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 13/14 (dimension 5) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 14/14 (dimension 5) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


Computing boundary-matrix in dimension 6.
Rank of the source-module : 26.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 1/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][5 <<AlLp[2 S3][2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 2/26 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 3/26 (dimension 6) :
<<AlLp[5 <<AlLp[2 S3][2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 4/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 5/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 6/26 (dimension 6) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 7/26 (dimension 6) :
<<AlLp[2 <D3>][2 <D3>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 8/26 (dimension 6) :
<<AlLp[2 <D3>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 9/26 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 10/26 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 11/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 12/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 13/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 14/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 15/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 16/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 17/26 (dimension 6) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 18/26 (dimension 6) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 19/26 (dimension 6) :
<<AlLp[2 <D3>][2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 20/26 (dimension 6) :
<<AlLp[3 <<AlLp[2 S3][2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 21/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 22/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 23/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 24/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 25/26 (dimension 6) :
<<AlLp[2 <D3>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.


;; Clock -> 2019-12-15, 22h 27m 59s.
Computing the boundary of the generator 26/26 (dimension 6) :
<<AlLp[1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>][1 <<AlLp[2 S3]>>]>>
End of computing.




Homology in dimension 5 :


Component Z/2Z

Component Z/2Z

Component Z/2Z

Component Z/2Z

Component Z/2Z

Component Z/2Z

Component Z


---done---

;; Clock -> 2019-12-15, 22h 27m 59s.

#+end_example

Let us continue with the Kan theory. First, we check that $S^3$ is not of
type Kan and that $\Omega S^3$ is indeed of type Kan and a non-Abelian
simplicial group.

#+BEGIN_SRC lisp
(typep s3 'kan)
#+END_SRC

#+RESULTS:
: NIL

#+BEGIN_SRC lisp
(typep os3 'kan)
#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp
(typep os3 'simplicial-group)
#+END_SRC

#+RESULTS:
: T

#+BEGIN_SRC lisp
(typep os3 'ab-simplicial-group)
#+END_SRC

#+RESULTS:
: NIL

Let us create the word $L2=(S3)^2$, i.e an object belonging to $\Omega S^3$
and let us apply the product of the underlying algebra upon $L2 \otimes L2$:

#+BEGIN_SRC lisp :exports none
(defvar L2)
#+END_SRC

#+RESULTS:
: L2

#+BEGIN_SRC lisp :results output
(princ (setf L2 (loop3 0 's3 2)))
#+END_SRC

#+RESULTS:
: <<Loop[S3\2]>>

#+BEGIN_SRC lisp :exports none
(defvar square)
#+END_SRC

#+RESULTS:
: SQUARE

#+BEGIN_SRC lisp :results output
(princ (setf square (aprd os3 4 (tnpr 2 L2 2 L2))))
#+END_SRC

#+RESULTS:
:
: ----------------------------------------------------------------------{CMBN 4}
: <1 * <<Loop[1-0 S3\2][3-2 S3\2]>>>
: <-1 * <<Loop[2-0 S3\2][3-1 S3\2]>>>
: <1 * <<Loop[2-1 S3\2][3-0 S3\2]>>>
: <1 * <<Loop[3-0 S3\2][2-1 S3\2]>>>
: <-1 * <<Loop[3-1 S3\2][2-0 S3\2]>>>
: <1 * <<Loop[3-2 S3\2][1-0 S3\2]>>>
: ------------------------------------------------------------------------------

We see that the result is a linear combination of words composed from
degeneracies of =L2=. The following instruction selects the generator part of
the second element of the previous combination.

#+BEGIN_SRC lisp :exports none
(defvar L4)
#+END_SRC

#+RESULTS:
: L4

#+BEGIN_SRC lisp :results output
(princ (setf L4 (gnrt (second (cmbn-list square)))))
#+END_SRC

#+RESULTS:
: <<Loop[2-0 S3\2][3-1 S3\2]>>

Let us use the lisp function =mapcar= (one among the various iteration
functions of Lisp) to create the list of the faces 1, 2, 3 and 4 of the
object =L4=, this list is a "Kan horn".

#+BEGIN_SRC lisp :exports none
(defvar horn)
#+END_SRC

#+RESULTS:
: HORN

#+BEGIN_SRC lisp :results output
(princ (setf horn (mapcar #'(lambda (i) (face os3 i 4 l4)) '(1 2 3 4))))
#+END_SRC

#+RESULTS:
: (<AbSm - <<Loop[1 S3\2][2 S3\2]>>> <AbSm - <<Loop[0 S3\2][2 S3\2]>>> <AbSm - <<Loop[0 S3\2][1 S3\2]>>> <AbSm 1 <<Loop[S3\2]>>>)

The function =kfll= tries to find a filling of this "Kan horn", and we see that
the face 2 of the resulting simplex (which is very different from =L4=) is the
same as the face 2 of =L4=.

#+BEGIN_SRC lisp :exports none
(defvar kan-simplex)
#+END_SRC

#+RESULTS:
: KAN-SIMPLEX

#+BEGIN_SRC lisp :results output
(princ (setf kan-simplex (kfll os3 0 4 horn)))
#+END_SRC

#+RESULTS:
: <AbSm - <<Loop[3-1 S3\2][2-1 S3\-2][2-0 S3\2][1-0 S3\-2][2-1 S3\2][3-1 S3\-2][1-0 S3\2][3-1 S3\2][3-0 S3\-2][1-0 S3\-2][3-0 S3\2][2-0 S3\-2][1-0 S3\2][3-0 S3\-2][2-0 S3\2][3-0 S3\2]>>>

#+BEGIN_SRC lisp :results output
(princ (face os3 2 4 kan-simplex))
#+END_SRC

#+RESULTS:
: <AbSm - <<Loop[0 S3\2][2 S3\2]>>>

#+BEGIN_SRC lisp :results output
(princ (second horn))
#+END_SRC

#+RESULTS:
: <AbSm - <<Loop[0 S3\2][2 S3\2]>>>

Let ${\cal G}$ be a simplicial group 0-reduced. $\Omega S^3$ is such a group.
The program =Kenzo= allows the construction of the universal bundle
$\mathcal{WG}$ and in particular of its base space $\overline{\mathcal{W}}
\mathcal{G}$, i.e. the classifying space of ${\cal G}$. In our case, as
$\Omega S^3$ in non-Abelian, the result is not a simplicial group but only a
simplicial set. We verify that the $H_4$, which in principle should be
isomorphic to $H_4 S^3 = 0$, is really null.

#+BEGIN_SRC lisp :exports none
(defvar cls-os3)
#+END_SRC

#+RESULTS:
: CLS-OS3

#+BEGIN_SRC lisp
(setf cls-os3 (classifying-space os3))
#+END_SRC

#+RESULTS:
: [K598 Simplicial-Set]

#+BEGIN_SRC lisp
(typep cls-os3 'simplicial-group)
#+END_SRC

#+RESULTS:
: NIL

#+BEGIN_SRC lisp :results output
(homology cls-os3 4)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 4.
Rank of the source-module : 0.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 1.


;; Clock -> 2019-12-15, 22h 28m 3s.
Computing the boundary of the generator 1/1 (dimension 5) :
<<Abar[5 <<AlLp[2 S3][2 S3]>>]>>
End of computing.




Homology in dimension 4 :



---done---

;; Clock -> 2019-12-15, 22h 28m 3s.

#+end_example

Let us end this short overview with an example of computation of homotopy
groups. The method used in =Kenzo= is the Whitehead tower. An extended version
of the Kenzo program due to Ana Romero is more general, but in this present
version only the case where the first non-null homology group (in non-null
dimension) is $\mathbb{Z}$ or $\mathbb{Z}/{2\mathbb{Z}}$ can be processed;
however if this homology group is a direct sum of several copies of
$\mathbb{Z}$ or $\mathbb{Z}/{2 \mathbb{Z}}$, then the corresponding stage of
the Whitehead tower may also be constructed step by step.

We take again $\mathrm{Moore}(\mathbb{Z}/2\mathbb{Z}, 3)$ whose $H_3$ is
$\mathbb{Z}/2\mathbb{Z}$. First the fundamental cohomology class is
constructed:

#+BEGIN_SRC lisp :exports none
(defvar ch3)
#+END_SRC

#+RESULTS:
: CH3

#+BEGIN_SRC lisp
(setf ch3 (chml-clss m23 3))
#+END_SRC

#+RESULTS:
: [K729 Cohomology-Class on K1 of degree 3]

Then the function =z2-whitehead= is called to build a fibration over the
simplicial set =m23= canonically associated to the cohomology class =ch3=.

#+BEGIN_SRC lisp :exports none
(defvar f3)
#+END_SRC

#+RESULTS:
: F3

#+BEGIN_SRC lisp
(setf f3 (z2-whitehead m23 ch3))
#+END_SRC

#+RESULTS:
: [K730 Fibration K1 -> K64]

Then the total space of the fibration is built:

#+BEGIN_SRC lisp :exports none
(defvar x4)
#+END_SRC

#+RESULTS:
: X4

#+BEGIN_SRC lisp
(setf x4 (fibration-total f3))
#+END_SRC

#+RESULTS:
: [K736 Simplicial-Set]

The $H_4$ of this total space is the $\pi_4$ of
$\mathrm{Moore}(\mathbb{Z}/2\mathbb{Z})$:

#+BEGIN_SRC lisp :results output
(homology x4 3 5)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 3.
Rank of the source-module : 2.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 1/2 (dimension 3) :
<TnPr * <<Abar[3 2]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 2/2 (dimension 3) :
<TnPr M3 <<Abar>>>
End of computing.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 3.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 1/3 (dimension 4) :
<TnPr * <<Abar[4 3]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 2/3 (dimension 4) :
<TnPr * <<Abar[2 1][2 1]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 3/3 (dimension 4) :
<TnPr N4 <<Abar>>>
End of computing.




Homology in dimension 3 :



---done---

;; Clock -> 2019-12-15, 22h 28m 5s.


Computing boundary-matrix in dimension 4.
Rank of the source-module : 3.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 1/3 (dimension 4) :
<TnPr * <<Abar[4 3]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 2/3 (dimension 4) :
<TnPr * <<Abar[2 1][2 1]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 3/3 (dimension 4) :
<TnPr N4 <<Abar>>>
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 4.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 1/4 (dimension 5) :
<TnPr * <<Abar[5 4]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 2/4 (dimension 5) :
<TnPr * <<Abar[2 1][3 2]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 3/4 (dimension 5) :
<TnPr * <<Abar[3 2][2 1]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 5s.
Computing the boundary of the generator 4/4 (dimension 5) :
<TnPr M3 <<Abar[2 1]>>>
End of computing.




Homology in dimension 4 :


Component Z/2Z


---done---

;; Clock -> 2019-12-15, 22h 28m 5s.

#+end_example

We may now iterate the process, to compute the $\pi_5$ of
$\mathrm{Moore}(\mathbb{Z}/2\mathbb{Z})$:

#+BEGIN_SRC lisp :exports none
(defvar ch4)
#+END_SRC

#+RESULTS:
: CH4

#+BEGIN_SRC lisp
(setf ch4 (chml-clss x4 4))
#+END_SRC

#+RESULTS:
: [K817 Cohomology-Class on K802 of degree 4]

#+BEGIN_SRC lisp :exports none
(defvar f4)
#+END_SRC

#+RESULTS:
: F4

#+BEGIN_SRC lisp
(setf f4 (z2-whitehead x4 ch4))
#+END_SRC

#+RESULTS:
: [K832 Fibration K736 -> K818]

#+BEGIN_SRC lisp :exports none
(defvar x5)
#+END_SRC

#+RESULTS:
: X5

#+BEGIN_SRC lisp
(setf x5 (fibration-total f4))
#+END_SRC

#+RESULTS:
: [K838 Simplicial-Set]

#+BEGIN_SRC lisp :results output
(homology x5 4 6)
#+END_SRC

#+RESULTS:
#+begin_example

Computing boundary-matrix in dimension 4.
Rank of the source-module : 4.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 1/4 (dimension 4) :
<TnPr <TnPr * <<Abar>>> <<Abar[4 <<Abar[3 2]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 2/4 (dimension 4) :
<TnPr <TnPr * <<Abar[4 3]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 3/4 (dimension 4) :
<TnPr <TnPr * <<Abar[2 1][2 1]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 4/4 (dimension 4) :
<TnPr <TnPr N4 <<Abar>>> <<Abar>>>
End of computing.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 7.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 1/7 (dimension 5) :
<TnPr <TnPr * <<Abar>>> <<Abar[5 <<Abar[4 3]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 2/7 (dimension 5) :
<TnPr <TnPr * <<Abar>>> <<Abar[5 <<Abar[2 1][2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 3/7 (dimension 5) :
<TnPr <TnPr * <<Abar[2 1]>>> <<Abar[3 <<Abar[2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 4/7 (dimension 5) :
<TnPr <TnPr * <<Abar[5 4]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 5/7 (dimension 5) :
<TnPr <TnPr * <<Abar[2 1][3 2]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 6/7 (dimension 5) :
<TnPr <TnPr * <<Abar[3 2][2 1]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 7/7 (dimension 5) :
<TnPr <TnPr M3 <<Abar[2 1]>>> <<Abar>>>
End of computing.




Homology in dimension 4 :



---done---

;; Clock -> 2019-12-15, 22h 28m 7s.


Computing boundary-matrix in dimension 5.
Rank of the source-module : 7.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 1/7 (dimension 5) :
<TnPr <TnPr * <<Abar>>> <<Abar[5 <<Abar[4 3]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 2/7 (dimension 5) :
<TnPr <TnPr * <<Abar>>> <<Abar[5 <<Abar[2 1][2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 3/7 (dimension 5) :
<TnPr <TnPr * <<Abar[2 1]>>> <<Abar[3 <<Abar[2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 4/7 (dimension 5) :
<TnPr <TnPr * <<Abar[5 4]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 5/7 (dimension 5) :
<TnPr <TnPr * <<Abar[2 1][3 2]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 6/7 (dimension 5) :
<TnPr <TnPr * <<Abar[3 2][2 1]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 7/7 (dimension 5) :
<TnPr <TnPr M3 <<Abar[2 1]>>> <<Abar>>>
End of computing.


Computing boundary-matrix in dimension 6.
Rank of the source-module : 14.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 1/14 (dimension 6) :
<TnPr <TnPr * <<Abar>>> <<Abar[6 <<Abar[5 4]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 2/14 (dimension 6) :
<TnPr <TnPr * <<Abar>>> <<Abar[6 <<Abar[2 1][3 2]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 3/14 (dimension 6) :
<TnPr <TnPr * <<Abar>>> <<Abar[6 <<Abar[3 2][2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 4/14 (dimension 6) :
<TnPr <TnPr * <<Abar>>> <<Abar[3 <<Abar[2 1]>>][3 <<Abar[2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 5/14 (dimension 6) :
<TnPr <TnPr * <<Abar[2 1]>>> <<Abar[4 <<Abar[3 2]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 6/14 (dimension 6) :
<TnPr <TnPr * <<Abar[3 2]>>> <<Abar[3 <<Abar[2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 7/14 (dimension 6) :
<TnPr <TnPr M3 <<Abar>>> <<Abar[3 <<Abar[2 1]>>]>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 8/14 (dimension 6) :
<TnPr <TnPr * <<Abar[6 5]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 9/14 (dimension 6) :
<TnPr <TnPr * <<Abar[2 1][4 3]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 10/14 (dimension 6) :
<TnPr <TnPr * <<Abar[3 2][3 2]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 11/14 (dimension 6) :
<TnPr <TnPr * <<Abar[4 3][2 1]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 12/14 (dimension 6) :
<TnPr <TnPr * <<Abar[2 1][2 1][2 1]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 13/14 (dimension 6) :
<TnPr <TnPr M3 <<Abar[3 2]>>> <<Abar>>>
End of computing.


;; Clock -> 2019-12-15, 22h 28m 7s.
Computing the boundary of the generator 14/14 (dimension 6) :
<TnPr <TnPr N4 <<Abar[2 1]>>> <<Abar>>>
End of computing.




Homology in dimension 5 :


Component Z/4Z


---done---

;; Clock -> 2019-12-15, 22h 28m 7s.

#+end_example

So $\pi_5(\mathrm{Moore}(\mathbb{Z}/2\mathbb{Z}))$ is
$\mathbb{Z}/4\mathbb{Z}$.
